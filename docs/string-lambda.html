<!DOCTYPE html>  <html> <head>   <title>string-lambda.js</title>   <meta http-equiv="content-type" content="text/html; charset=UTF-8">   <link rel="stylesheet" media="all" href="docco.css" /> </head> <body>   <div id="container">     <div id="background"></div>            <div id="jump_to">         Jump To &hellip;         <div id="jump_wrapper">           <div id="jump_page">                                           <a class="source" href="serenity.html">                 serenity.js               </a>                                           <a class="source" href="application.html">                 application.js               </a>                                           <a class="source" href="array_controller.html">                 array_controller.js               </a>                                           <a class="source" href="controller.html">                 controller.js               </a>                                           <a class="source" href="enumerable.html">                 enumerable.js               </a>                                           <a class="source" href="inflector.html">                 inflector.js               </a>                                           <a class="source" href="model.html">                 model.js               </a>                                           <a class="source" href="object.html">                 object.js               </a>                                           <a class="source" href="view.html">                 view.js               </a>                                           <a class="source" href="string-lambda.html">                 string-lambda.js               </a>                                           <a class="source" href="underscore.html">                 underscore.js               </a>                        </div>         </div>       </div>          <table cellpadding="0" cellspacing="0">       <thead>         <tr>           <th class="docs">             <h1>               string-lambda.js             </h1>           </th>           <th class="code">           </th>         </tr>       </thead>       <tbody>                               <tr id="section-1">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>                            </td>             <td class="code">               <div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Author: Oliver Steele</span>
<span class="cm"> * Copyright: Copyright 2007 by Oliver Steele.  All rights reserved.</span>
<span class="cm"> * License: MIT License</span>
<span class="cm"> * Homepage: http://osteele.com/javascripts/functional</span>
<span class="cm"> * Created: 2007-07-11</span>
<span class="cm"> * Version: 1.0.2</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This defines &quot;string lambdas&quot;, that allow strings such as `x+1` and</span>
<span class="cm"> * `x -&gt; x+1` to be used in some contexts as functions.</span>
<span class="cm"> */</span></pre></div>             </td>           </tr>                               <tr id="section-2">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-2">&#182;</a>               </div>               <p>/ ^ String lambdas</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Turns a string that contains a JavaScript expression into a</span>
<span class="cm"> * `Function` that returns the value of that expression.</span>
<span class="cm"> *</span>
<span class="cm"> * If the string contains a `-&gt;`, this separates the parameters from the body:</span>
<span class="cm"> * &gt;&gt; &#39;x -&gt; x + 1&#39;.lambda()(1) -&gt; 2</span>
<span class="cm"> * &gt;&gt; &#39;x y -&gt; x + 2*y&#39;.lambda()(1, 2) -&gt; 5</span>
<span class="cm"> * &gt;&gt; &#39;x, y -&gt; x + 2*y&#39;.lambda()(1, 2) -&gt; 5</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise, if the string contains a `_`, this is the parameter:</span>
<span class="cm"> * &gt;&gt; &#39;_ + 1&#39;.lambda()(1) -&gt; 2</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise if the string begins or ends with an operator or relation,</span>
<span class="cm"> * prepend or append a parameter.  (The documentation refers to this type</span>
<span class="cm"> * of string as a &quot;section&quot;.)</span>
<span class="cm"> * &gt;&gt; &#39;/2&#39;.lambda()(4) -&gt; 2</span>
<span class="cm"> * &gt;&gt; &#39;2/&#39;.lambda()(4) -&gt; 0.5</span>
<span class="cm"> * &gt;&gt; &#39;/&#39;.lambda()(2,4) -&gt; 0.5</span>
<span class="cm"> * Sections can end, but not begin with, `-`.  (This is to avoid interpreting</span>
<span class="cm"> * e.g. `-2*x` as a section).  On the other hand, a string that either begins</span>
<span class="cm"> * or ends with `/` is a section, so an expression that begins or ends with a</span>
<span class="cm"> * regular expression literal needs an explicit parameter.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise, each variable name is an implicit parameter:</span>
<span class="cm"> * &gt;&gt; &#39;x + 1&#39;.lambda()(1) -&gt; 2</span>
<span class="cm"> * &gt;&gt; &#39;x + 2*y&#39;.lambda()(1, 2) -&gt; 5</span>
<span class="cm"> * &gt;&gt; &#39;y + 2*x&#39;.lambda()(1, 2) -&gt; 5</span>
<span class="cm"> *</span>
<span class="cm"> * Implicit parameter detection ignores strings literals, variable names that</span>
<span class="cm"> * start with capitals, and identifiers that precede `:` or follow `.`:</span>
<span class="cm"> * &gt;&gt; map(&#39;&quot;im&quot;+root&#39;, [&quot;probable&quot;, &quot;possible&quot;]) -&gt; [&quot;improbable&quot;, &quot;impossible&quot;]</span>
<span class="cm"> * &gt;&gt; &#39;Math.cos(angle)&#39;.lambda()(Math.PI) -&gt; -1</span>
<span class="cm"> * &gt;&gt; &#39;point.x&#39;.lambda()({x:1, y:2}) -&gt; 1</span>
<span class="cm"> * &gt;&gt; &#39;({x:1, y:2})[key]&#39;.lambda()(&#39;x&#39;) -&gt; 1</span>
<span class="cm"> *</span>
<span class="cm"> * Implicit parameter detection mistakenly looks inside regular expression</span>
<span class="cm"> * literals for variable names.  It also doesn&#39;t know to ignore JavaScript</span>
<span class="cm"> * keywords and bound variables.  (The only way you can get these last two is</span>
<span class="cm"> * with a function literal inside the string.  This is outside the intended use</span>
<span class="cm"> * case for string lambdas.)</span>
<span class="cm"> *</span>
<span class="cm"> * Use `_` (to define a unary function) or `-&gt;`, if the string contains anything</span>
<span class="cm"> * that looks like a free variable but shouldn&#39;t be used as a parameter, or</span>
<span class="cm"> * to specify parameters that are ordered differently from their first</span>
<span class="cm"> * occurrence in the string.</span>
<span class="cm"> *</span>
<span class="cm"> * Chain `-&gt;`s to create a function in uncurried form:</span>
<span class="cm"> * &gt;&gt; &#39;x -&gt; y -&gt; x + 2*y&#39;.lambda()(1)(2) -&gt; 5</span>
<span class="cm"> * &gt;&gt; &#39;x -&gt; y -&gt; z -&gt; x + 2*y+3*z&#39;.lambda()(1)(2)(3) -&gt; 14</span>
<span class="cm"> *</span>
<span class="cm"> * `this` and `arguments` are special:</span>
<span class="cm"> * &gt;&gt; &#39;this&#39;.call(1) -&gt; 1</span>
<span class="cm"> * &gt;&gt; &#39;[].slice.call(arguments, 0)&#39;.call(null,1,2) -&gt; [1, 2]</span>
<span class="cm"> */</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">lambda</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="nx">expr</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
        <span class="nx">sections</span> <span class="o">=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">ECMAsplit</span><span class="p">(</span><span class="sr">/\s*-&gt;\s*/m</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">sections</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">sections</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">expr</span> <span class="o">=</span> <span class="nx">sections</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
            <span class="nx">params</span> <span class="o">=</span> <span class="nx">sections</span><span class="p">.</span><span class="nx">pop</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="sr">/\s*,\s*|\s+/m</span><span class="p">);</span>
            <span class="nx">sections</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">sections</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;(function(&#39;</span><span class="o">+</span><span class="nx">params</span><span class="o">+</span><span class="s1">&#39;){return (&#39;</span><span class="o">+</span><span class="nx">expr</span><span class="o">+</span><span class="s1">&#39;)})&#39;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">expr</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/\b_\b/</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">params</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div>             </td>           </tr>                               <tr id="section-3">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-3">&#182;</a>               </div>               <p>test whether an operator appears on the left (or right), respectively</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="kd">var</span> <span class="nx">leftSection</span> <span class="o">=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^\s*(?:[+*\/%&amp;|\^\.=&lt;&gt;]|!=)/m</span><span class="p">),</span>
            <span class="nx">rightSection</span> <span class="o">=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/[+\-*\/%&amp;|\^\.=&lt;&gt;!]\s*$/m</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">leftSection</span> <span class="o">||</span> <span class="nx">rightSection</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">leftSection</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">params</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;$1&#39;</span><span class="p">);</span>
                <span class="nx">expr</span> <span class="o">=</span> <span class="s1">&#39;$1&#39;</span> <span class="o">+</span> <span class="nx">expr</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">rightSection</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">params</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;$2&#39;</span><span class="p">);</span>
                <span class="nx">expr</span> <span class="o">=</span> <span class="nx">expr</span> <span class="o">+</span> <span class="s1">&#39;$2&#39;</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div>             </td>           </tr>                               <tr id="section-4">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-4">&#182;</a>               </div>               <p><code>replace</code> removes symbols that are capitalized, follow '.',
precede ':', are 'this' or 'arguments'; and also the insides of
strings (by a crude test).  <code>match</code> extracts the remaining
symbols.</p>             </td>             <td class="code">               <div class="highlight"><pre>            <span class="kd">var</span> <span class="nx">vars</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/(?:\b[A-Z]|\.[a-zA-Z_$])[a-zA-Z_$\d]*|[a-zA-Z_$][a-zA-Z_$\d]*\s*:|this|arguments|&#39;(?:[^&#39;\\]|\\.)*&#39;|&quot;(?:[^&quot;\\]|\\.)*&quot;/g</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">match</span><span class="p">(</span><span class="sr">/([a-z_$][a-z_$\d]*)/gi</span><span class="p">)</span> <span class="o">||</span> <span class="p">[];</span> <span class="c1">// &#39;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">v</span><span class="p">;</span> <span class="nx">v</span> <span class="o">=</span> <span class="nx">vars</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">];</span> <span class="p">)</span>
                <span class="nx">params</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">params</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Function</span><span class="p">(</span><span class="nx">params</span><span class="p">,</span> <span class="s1">&#39;return (&#39;</span> <span class="o">+</span> <span class="nx">expr</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">);</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-5">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-5">&#182;</a>               </div>               <p>/ Turn on caching for <code>string</code> -> <code>Function</code> conversion.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">lambda</span><span class="p">.</span><span class="nx">cache</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">proto</span> <span class="o">=</span> <span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span>
        <span class="nx">cache</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="nx">uncached</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">lambda</span><span class="p">,</span>
        <span class="nx">cached</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	        <span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// avoid hidden properties on Object.prototype</span>
	        <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">uncached</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
        <span class="p">};</span>
    <span class="nx">cached</span><span class="p">.</span><span class="nx">cached</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){};</span>
    <span class="nx">cached</span><span class="p">.</span><span class="nx">uncache</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span><span class="nx">proto</span><span class="p">.</span><span class="nx">lambda</span> <span class="o">=</span> <span class="nx">uncached</span><span class="p">};</span>
    <span class="nx">proto</span><span class="p">.</span><span class="nx">lambda</span> <span class="o">=</span> <span class="nx">cached</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ^^ Duck-Typing</span>
<span class="cm"> *</span>
<span class="cm"> * Strings support `call` and `apply`.  This duck-types them as</span>
<span class="cm"> * functions, to some callers.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * Coerce the string to a function and then apply it.</span>
<span class="cm"> * &gt;&gt; &#39;x+1&#39;.apply(null, [2]) -&gt; 3</span>
<span class="cm"> * &gt;&gt; &#39;/&#39;.apply(null, [2, 4]) -&gt; 0.5</span>
<span class="cm"> */</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">apply</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">toFunction</span><span class="p">().</span><span class="nx">apply</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Coerce the string to a function and then call it.</span>
<span class="cm"> * &gt;&gt; &#39;x+1&#39;.call(null, 2) -&gt; 3</span>
<span class="cm"> * &gt;&gt; &#39;/&#39;.call(null, 2, 4) -&gt; 0.5</span>
<span class="cm"> */</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">toFunction</span><span class="p">().</span><span class="nx">apply</span><span class="p">(</span><span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-6">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-6">&#182;</a>               </div>               <p>/ ^^ Coercion</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Returns a `Function` that perfoms the action described by this</span>
<span class="cm"> * string.  If the string contains a `return`, applies</span>
<span class="cm"> * `new Function` to it.  Otherwise, this function returns</span>
<span class="cm"> *  the result of `this.lambda()`.</span>
<span class="cm"> * &gt;&gt; &#39;+1&#39;.toFunction()(2) -&gt; 3</span>
<span class="cm"> * &gt;&gt; &#39;return 1&#39;.toFunction()(1) -&gt; 1</span>
<span class="cm"> */</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">body</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">body</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/\breturn\b/</span><span class="p">))</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nb">Function</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">lambda</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Returns this function.  `Function.toFunction` calls this.</span>
<span class="cm"> * &gt;&gt; &#39;+1&#39;.lambda().toFunction()(2) -&gt; 3</span>
<span class="cm"> */</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Coerces `fn` into a function if it is not already one,</span>
<span class="cm"> * by calling its `toFunction` method.</span>
<span class="cm"> * &gt;&gt; Function.toFunction(function() {return 1})() -&gt; 1</span>
<span class="cm"> * &gt;&gt; Function.toFunction(&#39;+1&#39;)(2) -&gt; 3</span>
<span class="cm"> *</span>
<span class="cm"> * `Function.toFunction` requires an argument that can be</span>
<span class="cm"> * coerced to a function.  A nullary version can be</span>
<span class="cm"> * constructed via `guard`:</span>
<span class="cm"> * &gt;&gt; Function.toFunction.guard()(&#39;1+&#39;) -&gt; function()</span>
<span class="cm"> * &gt;&gt; Function.toFunction.guard()(null) -&gt; null</span>
<span class="cm"> *</span>
<span class="cm"> * `Function.toFunction` doesn&#39;t coerce arbitrary values to functions.</span>
<span class="cm"> * It might seem convenient to treat</span>
<span class="cm"> * `Function.toFunction(value)` as though it were the</span>
<span class="cm"> * constant function that returned `value`, but it&#39;s rarely</span>
<span class="cm"> * useful and it hides errors.  Use `Functional.K(value)` instead,</span>
<span class="cm"> * or a lambda string when the value is a compile-time literal:</span>
<span class="cm"> * &gt;&gt; Functional.K(&#39;a string&#39;)() -&gt; &quot;a string&quot;</span>
<span class="cm"> * &gt;&gt; Function.toFunction(&#39;&quot;a string&quot;&#39;)() -&gt; &quot;a string&quot;</span>
<span class="cm"> */</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">toFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toFunction</span><span class="p">();</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-7">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-7">&#182;</a>               </div>               <p>Utilities</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-8">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-8">&#182;</a>               </div>               <p>IE6 split is not ECMAScript-compliant.  This breaks '->1'.lambda().
ECMAsplit is an ECMAScript-compliant <code>split</code>, although only for
one argument.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">ECMAsplit</span> <span class="o">=</span></pre></div>             </td>           </tr>                               <tr id="section-9">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-9">&#182;</a>               </div>               <p>The test is from the ECMAScript reference.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="p">(</span><span class="s1">&#39;ab&#39;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/a*/</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span>
     <span class="o">?</span> <span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">split</span>
     <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">separator</span><span class="p">,</span> <span class="nx">limit</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">limit</span> <span class="o">!=</span> <span class="s1">&#39;undefined&#39;</span><span class="p">)</span>
             <span class="k">throw</span> <span class="s2">&quot;ECMAsplit: limit is unimplemented&quot;</span><span class="p">;</span>
         <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">split</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">),</span>
             <span class="nx">re</span> <span class="o">=</span> <span class="nb">RegExp</span><span class="p">(</span><span class="nx">separator</span><span class="p">),</span>
             <span class="nx">savedIndex</span> <span class="o">=</span> <span class="nx">re</span><span class="p">.</span><span class="nx">lastIndex</span><span class="p">,</span>
             <span class="nx">match</span> <span class="o">=</span> <span class="nx">re</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
         <span class="k">if</span> <span class="p">(</span><span class="nx">match</span> <span class="o">&amp;&amp;</span> <span class="nx">match</span><span class="p">.</span><span class="nx">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
             <span class="nx">result</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-10">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-10">&#182;</a>               </div>               <p>in case <code>separator</code> was already a RegExp:</p>             </td>             <td class="code">               <div class="highlight"><pre>         <span class="nx">re</span><span class="p">.</span><span class="nx">lastIndex</span> <span class="o">=</span> <span class="nx">savedIndex</span><span class="p">;</span>
         <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
     <span class="p">});</span>

</pre></div>             </td>           </tr>                </tbody>     </table>   </div> </body> </html> 