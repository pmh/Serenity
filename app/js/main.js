var __DEV__ = true;
// modulr.sync.js (c) 2010 Tobie Langel
(function(exports) {
  var _factories = {},
      _modules = {},
      PREFIX = '__module__', // Poor man's hasOwnProperty
      RELATIVE_IDENTIFIER_PATTERN = /^\.\.?\//;
      
  function makeRequire(id, main) {
    // Find the requirer's dirname from it's id.
    var path = id.substring(0, id.lastIndexOf('/') + 1);
    
    function require(identifier) {
      var id = resolveIdentifier(identifier, path),
          key = PREFIX + id,
          mod = _modules[key];

      // Check if this module's factory has already been called.
      if (!mod) {

        var fn = _factories[key];
        delete _factories[key]; // no longer needed.

        if (!fn) { throw 'Can\'t find module "' + identifier + '".'; }

        // lazy eval
        if (typeof fn === 'string') {
          fn = new Function('require', 'exports', 'module', fn);
        }

        _modules[key] = mod = { id: id, exports: {} };
        // Create an instance of `require` per module. Each instance has a
        // reference to the path it was called from to be able to properly
        // resolve relative identifiers.
        // `main` isn't defined until we actually require the program's
        // entry point.
        var r = makeRequire(id, main || mod);
        fn(r, mod.exports, mod);
      }
      return mod.exports;
    }

    require.main = main;
    return require;
  }

  function resolveIdentifier(identifier, dir) {
    var parts, part, path;
    
    if (!RELATIVE_IDENTIFIER_PATTERN.test(identifier)) {
      return identifier;
    }

    parts = (dir + identifier).split('/');

    path = [];
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      switch (part) {
        case '':
        case '.':
          continue;
        case '..':
          if (path.length) {
            path.pop();
          } else {
            throw new RangeError('Out of bounds identifier: ' + identifier);
          }
          break;
        default:
          path.push(part);
      }
    }
    return path.join('/');
  }
  
  function define(id, factory) {
    _factories[PREFIX + id] = factory;
  }
  
  exports.define = define;
  exports.require = makeRequire('');
})(this);

// module: templates
// file:   templates.js
eval("define(\"templates\", function(require, exports, module) { var templates = module.exports = {};\n\ntemplates[\"hello/hello\"] = \"<span data-bind='text: greeting'></span>\";\n\n\n//@ sourceURL=templates.js\n});");

// module: lib/serenity/model
// file:   lib/serenity/model.js
eval("define(\"lib/serenity/model\", function(require, exports, module) { var Serenity = { Object: require('./object') }\n  , Model    = Serenity.Object.clone();\n\nModel.release = function() {};\n\nmodule.exports = Model;\n//@ sourceURL=lib/serenity/model.js\n});");

// module: views/hello_view
// file:   views/hello_view.js
eval("define(\"views/hello_view\", function(require, exports, module) { var HelloView = Serenity.View.clone(function () {\n  this.template = 'hello/hello'\n\n  this.property(\"greeting\");\n\n  this.init = function () {\n    this.greeting = \"Hello, from Serenity!\";\n  };\n});\n\nmodule.exports = HelloView;\n//@ sourceURL=views/hello_view.js\n});");

// module: lib/serenity/controller
// file:   lib/serenity/controller.js
eval("define(\"lib/serenity/controller\", function(require, exports, module) { var Serenity   = { Object: require('./object') }\n  , Controller = Serenity.Object.clone();\n\nController.model = function() {};\nController.release = function() {};\n\nController.type = \"Controller\"\n\nmodule.exports = Controller;\n\n//@ sourceURL=lib/serenity/controller.js\n});");

// module: main
// file:   main.js
eval("define(\"main\", function(require, exports, module) { window.ko = require('./vendor/knockout-debug');\nrequire('./vendor/jquery-transition');\n\nwindow.Templates = require('./templates');\nwindow.Serenity  = require('./lib/serenity');\nwindow._         = require('./vendor/underscore');\n\nrequire('./vendor/postal');\nrequire(\"./states/states\");\n\nsetTimeout(function () {\n  postal.publish(\"application\", \"initialize\", {});\n}, 3000);\n//@ sourceURL=main.js\n});");

// module: lib/serenity
// file:   lib/serenity.js
eval("define(\"lib/serenity\", function(require, exports, module) { require('./serenity/utils/core-ext');\n\nSerenity = {\n    Object      : require('./serenity/object'),\n    Model       : require('./serenity/model'),\n    Controller  : require('./serenity/controller'),\n    ArrayProxy  : require('./serenity/array-proxy'),\n    View        : require('./serenity/view'),\n    Enumerable  : require('./serenity/enumerable')\n};\n\nmodule.exports = Serenity;\n//@ sourceURL=lib/serenity.js\n});");

// module: states/states
// file:   states/states.js
eval("define(\"states/states\", function(require, exports, module) { var machina = require( '../vendor/machina' );\n\nvar states  = new machina.Fsm({\n  messaging: {\n    provider         : \"postal\",\n    eventNamespace   : \"application.events\",\n    handlerNamespace : \"application\"\n  },\n\n  initialState: \"uninitialized\",\n\n  states: {\n    uninitialized: {\n      initialize: function() {\n        // Initialize application.\n        $(\"#splash\").hide();\n        require(\"views/hello_view\").display();\n      },\n    },\n  }\n});\n\nmodule.exports = states;\n//@ sourceURL=states/states.js\n});");

// module: lib/serenity/array-proxy
// file:   lib/serenity/array-proxy.js
eval("define(\"lib/serenity/array-proxy\", function(require, exports, module) { var MVC, ArrayProxy;\n\nMVC = {\n  Controller: require('./controller'),\n  Enumerable: require('./enumerable')\n};\n\nArrayProxy = MVC.Controller.clone(function () {\n  this.properties('collection', 'selectedItem');\n  this.collection = [];\n  \n  this.extend(MVC.Enumerable, this._collection);\n	\n	this.type = \"ArrayProxy\";\n});\n\nArrayProxy.push = function (obj) {\n  this._collection.push(obj);\n};\n\nArrayProxy.remove = function (obj) {\n  this._collection.remove(obj);\n};\n\nArrayProxy.removeAll = function () {\n  this._collection.removeAll();\n};\n\nArrayProxy.pop = function () {\n  this._collection.pop();\n};\n\nArrayProxy.unshift = function (obj) {\n  this._collection.unshift(obj);\n};\n\nArrayProxy.reverse = function () {\n  this._collection.reverse();\n};\n\nArrayProxy.sort = function (fn) {\n  this._collection.sort(fn);\n};\n\nArrayProxy.splice = function (start, end) {\n  this._collection.splice(start, end);\n};\n\nmodule.exports = ArrayProxy;\n//@ sourceURL=lib/serenity/array-proxy.js\n});");

// module: lib/serenity/view
// file:   lib/serenity/view.js
eval("define(\"lib/serenity/view\", function(require, exports, module) { var Serenity  = { Object: require('./object'), Templates: require('../../templates') }\n  , View = Serenity.Object.clone();\n\nView.create = function (config) {\n  return this.clone(function () {\n    this.init(config);\n    if (config.init) config.init.call(this);\n  });\n};\n\nView.cloned = function (view) {\n  view.init.call(view);\n  \n  if (view.controller) {\n    view.controller.model = view.model;\n    view.controller.view  = view;\n    if (view.controller.init) view.controller.init();\n  }\n};\n\nView.init = function (config) {\n  this.extend(config);\n  \n  if (this.controller) {\n    this.controller.model = this.model;\n    this.controller.view  = this;\n  }\n};\n\n\nView.display = function () {\n  var tmpl = $('div[data-template-path=\"' + this.template + '\"]');\n  tmpl.css(this.styles || {});\n  //tmpl.css('opacity', '1');\n  tmpl.html(Serenity.Templates[this.template]);\n  ko.applyBindings(this, tmpl[0]);\n  tmpl.css('display', 'block');\n  this.send('subviews', 'display');\n\n  if (this.animateTransition) {\n    tmpl.css('opacity', '0');\n    tmpl.animate({opacity: 1}, 200, 'linear');\n  }\n  postal.channel(\"View.\" + this.template, \"afterDisplay\").publish();\n\n  return this;\n};\n\nView.send = function (coll, message) {\n  this[coll] = this[coll] || [];\n  \n  var i, len = this[coll].length;\n  for (i = 0; i < len; i++) this[coll][i][message]();\n};\n\nView._cleanNode = function() {\n  var tmpl = $('div[data-template-path=\"' + this.template + '\"]');\n  ko.cleanNode(tmpl[0]);\n}\n\nView.release = function () {\n  var tmpl = $('div[data-template-path=\"' + this.template + '\"]');\n  \n  this.send('subviews', '_cleanNode');\n  this._cleanNode();\n\n  if (this.animateTransition) {\n    tmpl.animate({opacity: 0}, 200, 'linear', function() {\n        tmpl.hide();\n        tmpl.empty();\n      }\n    );\n  }\n  else {\n    tmpl.empty();\n    tmpl.hide();\n  }\n  //tmpl.html(\"\");\n  /*tmpl.css('opacity', '0');\n  tmpl.hide();*/\n\n  if (this.controller) {\n    this.controller.release();\n  }\n  if (this.model) {\n    this.model.release();\n  }\n  this.send('subviews', 'release');\n  \n  \n\n  return this;\n};\n\nmodule.exports = View;\n//@ sourceURL=lib/serenity/view.js\n});");

// module: lib/serenity/utils/core-ext
// file:   lib/serenity/utils/core-ext.js
eval("define(\"lib/serenity/utils/core-ext\", function(require, exports, module) { require('../../../vendor/string-lambda');\n\nvar Enumerable = require('../enumerable');\n\nFunction.prototype.computed = function (ctx) {\n  var self = this;\n  return function() {return ctx ? ko.computed(self, ctx) : ko.computed(self);};\n};\n\nFunction.prototype.withMeta = function (metaData) {\n  for (var slot in metaData)\n    if (metaData.hasOwnProperty(slot))\n      this[slot] = metaData[slot];\n\n  return this;\n}\n\nArray.prototype.each = Enumerable.each;\n\nif (!Array.prototype.map) {\n  Array.prototype.map = Enumerable.map;\n};\n\nif (!Array.prototype.reduce) {\n  Array.prototype.reduce = Enumerable.reduce;\n};\n\nif (!Array.prototype.reduceRight) {\n  Array.prototype.reduceRight = Enumerable.reduceRight;\n};\n\nif (!Array.prototype.find) {\n  Array.prototype.find = Enumerable.find;\n};\n\nif (!Array.prototype.filter) {\n  Array.prototype.filter = Enumerable.filter;\n};\n\nif (!Array.prototype.reject) {\n  Array.prototype.reject = Enumerable.reject;\n};\n\nif (!Array.prototype.every) {\n  Array.prototype.every = Enumerable.every;\n};\n\nif (!Array.prototype.some) {\n  Array.prototype.some = Enumerable.some;\n};\n\nif (!Array.prototype.contains) {\n  Array.prototype.contains = Enumerable.contains;\n};\n\nif (!Array.prototype.invoke) {\n  Array.prototype.invoke = Enumerable.invoke;\n};\n\nif (!Array.prototype.pluck) {\n  Array.prototype.pluck = Enumerable.pluck;\n};\n\nif (!Array.prototype.max) {\n  Array.prototype.max = Enumerable.max;\n};\n\nif (!Array.prototype.min) {\n  Array.prototype.min = Enumerable.min;\n};\n\nif (!Array.prototype.shuffle) {\n  Array.prototype.shuffle = Enumerable.shuffle;\n};\n\nif (!Array.prototype.sortBy) {\n  Array.prototype.sortBy = Enumerable.sortBy;\n};\n\nif (!Array.prototype.groupBy) {\n  Array.prototype.groupBy = Enumerable.groupBy;\n};\n\nif (!Array.prototype.sortedIndex) {\n  Array.prototype.sortedIndex = Enumerable.sortedIndex;\n};\n\nif (!Array.prototype.first) {\n  Array.prototype.first = Enumerable.first;\n};\n\nif (!Array.prototype.initial) {\n  Array.prototype.initial = Enumerable.initial;\n};\n\nif (!Array.prototype.last) {\n  Array.prototype.last = Enumerable.last;\n};\n\nif (!Array.prototype.rest) {\n  Array.prototype.rest = Enumerable.rest;\n};\n\nif (!Array.prototype.compact) {\n  Array.prototype.compact = Enumerable.compact;\n};\n\nif (!Array.prototype.flatten) {\n  Array.prototype.flatten = Enumerable.flatten;\n};\n\nif (!Array.prototype.without) {\n  Array.prototype.without = Enumerable.without;\n};\n\nif (!Array.prototype.unique) {\n  Array.prototype.unique = Enumerable.unique;\n};\n\nif (!Array.prototype.union) {\n  Array.prototype.union = Enumerable.union;\n};\n\nif (!Array.prototype.intersection) {\n  Array.prototype.intersection = Enumerable.intersection;\n};\n\nif (!Array.prototype.difference) {\n  Array.prototype.difference = Enumerable.difference;\n};\n\nif (!Array.prototype.zip) {\n  Array.prototype.zip = Enumerable.zip;\n};\n\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = Enumerable.indexOf;\n};\n\nif (!Array.prototype.lastIndexOf) {\n  Array.prototype.lastIndexOf = Enumerable.lastIndexOf;\n};\n\nif (!Array.prototype.remove) {\n  Array.prototype.remove = Enumerable.remove;\n};\n\nObject[\"merge\"] = function (target) {\n  var args = Array.prototype.slice.call(arguments).slice(1);\n  args.each(function (source) {\n    for (var key in source)\n      target[key] = source[key];\n  });\n\n  return target;\n};\n//@ sourceURL=lib/serenity/utils/core-ext.js\n});");

// module: vendor/postal
// file:   vendor/postal.js
eval("define(\"vendor/postal\", function(require, exports, module) { (function(a,b){var c=\"/\",d=50,e=0,f=\"postal\",g=function(){},h=function(a){var b={envelope:{}},d;switch(a.length){case 3:typeof a[1]==\"Object\"&&typeof a[2]==\"Object\"?(b.envelope.exchange=c,b.envelope.topic=a[0],b.payload=a[1],d=b.envelope,b.envelope=_.extend(d,a[2])):(b.envelope.exchange=a[0],b.envelope.topic=a[1],b.payload=a[2]);break;case 4:b.envelope.exchange=a[0],b.envelope.topic=a[1],b.payload=a[2],d=b.envelope,b.envelope=_.extend(d,a[3]);break;default:b.envelope.exchange=c,b.envelope.topic=a[0],b.payload=a[1]}return b},i=function(){var a;return function(b){var c=!1;return _.isString(b)?(c=b===a,a=b):(c=_.isEqual(b,a),a=_.clone(b)),!c}},j=function(a,b){this.exchange=a,this.topic=b};j.prototype={\n  subscribe:function(a){\n    var b=new k(this.exchange,this.topic,a);\n    return n.configuration.bus.subscribe(b),b},publish:function(a,b){var c=_.extend({exchange:this.exchange,timeStamp:new Date,topic:this.topic},b);n.configuration.bus.publish(a,c)}};var k=function(a,b,c){this.exchange=a,this.topic=b,this.callback=c,this.priority=d,this.constraints=[],this.maxCalls=e,this.onHandled=g,this.context=null,n.publish(f,\"subscription.created\",{event:\"subscription.created\",exchange:a,topic:b})};k.prototype={unsubscribe:function(){n.configuration.bus.unsubscribe(this),n.publish(f,\"subscription.removed\",{event:\"subscription.removed\",exchange:this.exchange,topic:this.topic})},defer:function(){var a=this.callback;return this.callback=function(b){setTimeout(a,0,b)},this},disposeAfter:function(a){if(_.isNaN(a)||a<=0)throw\"The value provided to disposeAfter (maxCalls) must be a number greater than zero.\";var b=this.onHandled,c=_.after(a,_.bind(function(){this.unsubscribe(this)},this));return this.onHandled=function(){b.apply(this.context,arguments),c()},this},ignoreDuplicates:function(){return this.withConstraint(new i),this},whenHandledThenExecute:function(a){if(!_.isFunction(a))throw\"Value provided to 'whenHandledThenExecute' must be a function\";return this.onHandled=a,this},withConstraint:function(a){if(!_.isFunction(a))throw\"Predicate constraint must be a function\";return this.constraints.push(a),this},withConstraints:function(a){var b=this;return _.isArray(a)&&_.each(a,function(a){b.withConstraint(a)}),b},withContext:function(a){return this.context=a,this},withDebounce:function(a){if(_.isNaN(a))throw\"Milliseconds must be a number\";var b=this.callback;return this.callback=_.debounce(b,a),this},withDelay:function(a){if(_.isNaN(a))throw\"Milliseconds must be a number\";var b=this.callback;return this.callback=function(c){setTimeout(b,a,c)},this},withPriority:function(a){if(_.isNaN(a))throw\"Priority must be a number\";return this.priority=a,this},withThrottle:function(a){if(_.isNaN(a))throw\"Milliseconds must be a number\";var b=this.callback;return this.callback=_.throttle(b,a),this}};var l={cache:{},compare:function(a,b){if(this.cache[b]&&this.cache[b][a])return!0;var c=new RegExp(\"^\"+this.regexify(a)+\"$\"),d=c.test(b);return d&&(this.cache[b]||(this.cache[b]={}),this.cache[b][a]=!0),d},regexify:function(a){return a.replace(/\\./g,\"\\\\.\").replace(/\\*/g,\".*\").replace(/#/g,\"[A-Z,a-z,0-9]*\")}},m={subscriptions:{},wireTaps:[],publish:function(a,b){this.notifyTaps(a,b),_.each(this.subscriptions[b.exchange],function(c){_.each(c,function(c){n.configuration.resolver.compare(c.topic,b.topic)&&_.all(c.constraints,function(b){return b(a)})&&typeof c.callback==\"function\"&&(c.callback.apply(c.context,[a,b]),c.onHandled())})})},subscribe:function(a){\n      var b,c,d;\n      this.subscriptions[a.exchange]||(this.subscriptions[a.exchange]={})\n      ,this.subscriptions[a.exchange][a.topic]||(this.subscriptions[a.exchange][a.topic]=[]),b=this.subscriptions[a.exchange][a.topic].length-1;\n      if(!_.any(this.subscriptions[a.exchange][a.topic],function(b){return b===a})){for(;b>=0;b--)if(this.subscriptions[a.exchange][a.topic][b].priority<=a.priority){this.subscriptions[a.exchange][a.topic].splice(b+1,0,a),c=!0;break}c||this.subscriptions[a.exchange][a.topic].unshift(a)}return _.bind(function(){this.unsubscribe(a)},this)},notifyTaps:function(a,b){_.each(this.wireTaps,function(c){c(a,b)})},unsubscribe:function(a){if(this.subscriptions[a.exchange][a.topic]){var b=this.subscriptions[a.exchange][a.topic].length,c=0;for(;c<b;c++)if(this.subscriptions[a.exchange][a.topic][c]===a){this.subscriptions[a.exchange][a.topic].splice(c,1);break}}},addWireTap:function(a){return this.wireTaps.push(a),function(){var b=this.wireTaps.indexOf(a);b!==-1&&this.wireTaps.splice(b,1)}}},n={configuration:{bus:m,resolver:l},channel:function(a,b){var d=arguments.length===2?a:c,e=arguments.length===2?b:a;return new j(d,e)},subscribe:function(a,b,d){var e=arguments.length===3?a:c,f=arguments.length===3?b:a,g=arguments.length===3?d:b,h=this.channel(e,f);return h.subscribe(g)},publish:function(a,b,c,d){var e=h([].slice.call(arguments,0)),f=this.channel(e.envelope.exchange,e.envelope.topic);f.publish(e.payload,e.envelope)},addWireTap:function(a){return this.configuration.bus.addWireTap(a)}};a.postal=n})(window)\n//@ sourceURL=vendor/postal.js\n});");

// module: vendor/machina
// file:   vendor/machina.js
eval("define(\"vendor/machina\", function(require, exports, module) { var machina=function(a,b){if(!a.deepExtend){var c={\"*\":function(a,b,c){a[b]=c},object:function(a,b,c){a[b]=f(a[b]||{},c)},array:function(b,d,f){b[d]=[],a.each(f,function(a,f){c[e(a)](b[d],f,a)},this)}},d=function(b){return a.isArray(b)?\"array\":a.isDate(b)?\"date\":a.isRegExp(b)?\"regex\":typeof b},e=function(a){var b=d(a);return c[b]?b:\"*\"},f=function(b){return a.each(g.call(arguments,1),function(d){a.each(d,function(a,d){c[e(a)](b,d,a)})}),b};a.mixin({deepExtend:f})}var g=[].slice,h=\"transition\",i=\"handler\",j=function(b){var c={};return a.each(b,function(a){c[a]=[]}),c},k=function(b){var c=b;return a.isArray(b)&&(c=j(b)),c},l={getHandlerNames:function(b){return a.uniq(a.flatten(a.map(b.states,function(b){return a.keys(b)})))},findProvider:function(){return window.postal?\"postal\":window.amplify?\"amplify\":b},makeFsmNamespace:function(){var a=0;return function(){return\"fsm.\"+a++}}(),getDefaultOptions:function(){return{initialState:\"uninitialized\",eventListeners:{\"*\":[]},states:{},eventQueue:[],messaging:function(){var a=l.makeFsmNamespace();return{provider:l.findProvider(),eventNamespace:a+\".events\",handlerNamespace:a,subscriptions:[]}}()}},standardEventTransforms:{Handling:function(a){var b=a;return b.eventType=b[1],delete b[1],b},Handled:function(a){var b=a;return b.eventType=b[1],delete b[1],b},Transitioned:function(a){var b=a;return b.oldState=b[1],b.newState=b[2],delete b[1],delete b[2],b},InvalidState:function(a){var b=a;return b.currentState=b[1],b.attemptedState=b[2],delete b[1],delete b[2],b},NoHandler:function(a){var b=a;return b.eventType=b[1],delete b[1],b}}},m={},n=function(){var b={},c=function(a){a.messaging.subscriptions.push(postal.subscribe(a.messaging.handlerNamespace,\"*\",function(a,b){this.handle.call(this,b.topic,a)}).withContext(a))},d=function(c){c.messaging.eventPublisher=function(){var d=arguments[0],e=a.deepExtend({},g.call(arguments,1));b[d]&&(e=b[d](e)),postal.publish(c.messaging.eventNamespace,d,e)},c.on(\"*\",c.messaging.eventPublisher)};return{wireUp:function(a){c(a),d(a)},addEventTransforms:function(c){a.deepExtend(b,c)}}};m.postal=new n,m.postal.addEventTransforms(l.standardEventTransforms);var o=function(){var b={},c=function(b){a.each(l.getHandlerNames(b),function(a){b.messaging.subscriptions.push(amplify.subscribe(b.messaging.handlerNamespace+\".\"+a,b,function(b){this.handle.call(this,a,b)}))})},d=function(c){c.messaging.eventPublisher=function(){var d=arguments[0],e=a.deepExtend({},g.call(arguments,1));b[d]&&(e=b[d](e)),amplify.publish(c.messaging.eventNamespace+\".\"+d,e)},c.on(\"*\",c.messaging.eventPublisher)};return{wireUp:function(a){c(a),d(a)},addEventTransforms:function(c){a.deepExtend(b,c)}}};m.amplify=new o,m.amplify.addEventTransforms(l.standardEventTransforms);var p=function(c){var d,e,f=l.getDefaultOptions();c&&(c.eventListeners&&(c.eventListeners=k(c.eventListeners)),c.messaging&&(c.messaging=a.extend({},f.messaging,c.messaging))),d=a.extend(f,c||{}),e=d.initialState,delete d.initialState,a.extend(this,d),this.messaging.provider&&m[this.messaging.provider]&&m[this.messaging.provider].wireUp(this),this.state=b,this._priorAction=\"\",this._currentAction=\"\",e&&this.transition(e),q.eventListeners.fireEvent(\"newFsm\",this)};p.prototype.fireEvent=function(b){var c=arguments;a.each(this.eventListeners[\"*\"],function(a){try{a.apply(this,g.call(c,0))}catch(b){console&&typeof console.log!=\"undefined\"&&console.log(b.toString())}}),this.eventListeners[b]&&a.each(this.eventListeners[b],function(a){try{a.apply(this,g.call(c,1))}catch(b){console&&typeof console.log!=\"undefined\"&&console.log(b.toString())}})},p.prototype.handle=function(a){var c=this.states,d=this.state,e=g.call(arguments,0),f;this.currentActionArgs=e,c[d]&&(c[d][a]||c[d][\"*\"])?(f=c[d][a]?a:\"*\",this._currentAction=d+\".\"+f,this.fireEvent.apply(this,[\"Handling\"].concat(e)),c[d][f].apply(this,e.slice(1)),this.fireEvent.apply(this,[\"Handled\"].concat(e)),this._priorAction=this._currentAction,this._currentAction=\"\",this.processQueue(i)):this.fireEvent.apply(this,[\"NoHandler\"].concat(e)),this.currentActionArgs=b},p.prototype.transition=function(a){if(this.states[a]){var b=this.state;this.state=a,this.states[a]._onEnter&&this.states[a]._onEnter.call(this),this.fireEvent.apply(this,[\"Transitioned\",b,this.state]),this.processQueue(h);return}this.fireEvent.apply(this,[\"InvalidState\",this.state,a])},p.prototype.processQueue=function(b){var c=b===h?function(a){return a.type===h&&(!a.untilState||a.untilState===this.state)}:function(a){return a.type===i},d=a.filter(this.eventQueue,c,this);this.eventQueue=a.difference(this.eventQueue,d),a.each(d,function(a,b){this.handle.apply(this,a.args)},this)},p.prototype.deferUntilTransition=function(a){if(this.currentActionArgs){var b={type:h,untilState:a,args:this.currentActionArgs};this.eventQueue.push(b),this.fireEvent.apply(this,[\"Deferred\",this.state,b])}},p.prototype.deferUntilNextHandler=function(){if(this.currentActionArgs){var a={type:h,args:this.currentActionArgs};this.eventQueue.push(a),this.fireEvent.apply(this,[\"Deferred\",this.state,a])}},p.prototype.on=function(a,b){this.eventListeners[a]||(this.eventListeners[a]=[]),this.eventListeners[a].push(b)},p.prototype.off=function(b,c){this.eventListeners[b]&&(this.eventListeners[b]=a.without(this.eventListeners[b],c))};var q={Fsm:p,busProviders:m,utils:l,on:function(a,b){if(this.eventListeners[a]){this.eventListeners[a].push(b);return}throw new Error(\"Invalid Event Name '\"+a+\"'.\")},off:function(b,c){throw this.eventListeners[b]&&(this.eventListeners[b]=a.without(this.eventListeners[b],c)),new Error(\"Invalid Event Name '\"+b+\"'.\")},eventListeners:{fireEvent:function(b){var c=0,d,e=arguments;this[b]&&a.each(this[b],function(a){a.apply(null,g.call(e,1))})},newFsm:[]}};return q}(_)\nmodule.exports = machina;\n//@ sourceURL=vendor/machina.js\n});");

// module: lib/serenity/object
// file:   lib/serenity/object.js
eval("define(\"lib/serenity/object\", function(require, exports, module) { var _Object = {\n  //\n  //  `_reserved` determines wether a certain word is reserved or not.\n  // Reserved words are ignored when iterating over an object.\n  //\n  _reserved: function (word) {\n    return word === \"parent\" || word === \"type\" || word.substring(0, 1) === \"_\";\n  },\n  \n  //\n  // Every Serenity.Object has a type field to aid in debbugging and also to enforce conventions.\n  //\n  type: \"Serenity.Object\",\n  \n  //\n  // `clone` is the corner stone of the Serenity object model. You could think of it as an \n  // object factory somewhat akin to Object.create but more powerful.\n  // When called it produces a new object who's prototype is the receiver of the clone message, \n  // it then invokes the passed in function in the context of this newly created object.\n  // It also adds a parent property to each object which points to it's prototype.\n  //\n  // One thing to note about Serenity's object model is that your always working with objects\n  // and there's no concept of classes so there's no distinction between class level (i.e., static proprties)\n  // and instance level properties.\n  // \n  //     // Creates a new object whose prototype is Object and\n  //     // assigns it to 'MyObj'\n  //     var MyObj = Object.clone(function () { this.stuff = [] });\n  //     \n  //     // Creates a new object whose prototype is MyObj and \n  //     // assigns it to 'myObj'\n  //     var myObj = MyObj.clone();\n  //     \n  //     myObj.stuff.push(1);\n  //     myObj.stuff;           //=> [1]\n  //     myObj.parent.stuff;    //=> []\n  //\n  clone: function (blk) {\n    var proto = this, F;\n    \n    F = function (parent) {\n      this.parent          = parent;\n      this._init           = blk || function () {};\n      this._before_filters = [];\n      \n      if (proto._init) proto._init.call(this, this);\n      this._init.call(this, this);\n       \n      if (parent.cloned) parent.cloned(this);\n    };\n    \n    F.prototype = proto;\n    F.prototype.constructor = F;\n    \n    return new F(proto);\n  },\n\n  //\n  // `create` clones an object and calls init with arguments.\n  //\n  create: function () {\n    var args = arguments;\n    return this.clone(function () {\n      if (this.init) this.init.apply(this, args);\n    });\n  },\n  \n  //\n  // `extend` copies all properties of the passed in object and installs them on it's receiver and \n  // then calls the extended hook method on that object (if one is defined) passing along the receiver\n  // as an argument.\n  // \n  // It can optionally take a context in wich case it will bind any method objects to that context.\n  // \n  //     var Foo = {\n  //       extended: function (obj) {\n  //         console.log(\"I will be called if someone extends me!\")\n  //       },\n  //       foo: \"bar\"\n  //     };\n  //     \n  //     var Bar = Serenity.Object.clone();\n  // \n  //     Bar.foo           //=> undefined\n  //     \n  //     Bar.extend(Foo);  //=> \"I will be called if someone extends me!\"\n  //     \n  //     Bar.foo           //=> \"bar\"\n  //\n  extend: function (obj, context) {\n    for (var slot in obj)\n      if (obj.hasOwnProperty(slot) && !this._reserved(slot))\n        this[slot] = (context && typeof obj[slot] === \"function\") ? obj[slot].bind(context) : obj[slot];\n    \n    if (obj && obj.extended) obj.extended(this);\n\n    return this;\n  },\n  \n  //\n  // `foreach` iterates over an object invoking the passed in function for it's side effects for every property.\n  //\n  forEach: function (fn) {\n    for (var slot in this)\n      if (this.hasOwnProperty(slot) && !this._reserved(slot)) fn.call(this, slot, this[slot]);\n  },\n  \n  // Defines one or more ko.observable properties on `this`.\n  set: function (obj) {\n    for (var key in obj) {\n      var isArray = Object.prototype.toString.apply(obj[key]).match(/Array/);\n      this[key] = isArray ? ko.observableArray(obj[key]) : ko.observable(obj[key]);\n    }\n  },\n  \n  // Defines one or more ko.observable properties on `this` and creates a getter and setter for each.\n  // You can access the original value through _propName.\n  // Aliased as properties\n  property: function () {\n    var i, len = arguments.length;\n    for (i = 0; i < len; i++) {\n      this._defineProperty(arguments[i]);\n    }\n  },\n  \n  _defineProperty: function (prop) {\n    var self = this;\n    this[\"_\" + prop] = ko.observable();\n    \n    this.__defineGetter__(prop, function () {\n      if (self['_' + prop]() === undefined) return null;\n      return self['_' + prop]();\n    });\n    \n    this.__defineSetter__(prop, function (val) {\n      if (this[\"_\" + prop]() === undefined) {\n        var isArray = Object.prototype.toString.apply(val).match(/Array/);\n        if (isArray) self[\"_\" + prop] = ko.observableArray(val);\n        else self[\"_\" + prop](val);\n      } else {\n        self['_' + prop](val);\n      }\n    });\n  },\n  \n  // Alias for property\n  properties: function () {\n    this.property.apply(this, arguments);\n  },\n  \n  //\n  // `before` takes the name of a function and a callback and will invoke the\n  // callback before the original method is invoked.\n  // \n  //     var foo = { bar: function () { console.log('bar') } };\n  //     foo.before('bar', function () { console.log('before bar') });\n  //    \n  //     foo.bar(); //=> \"before bar\"\n  //                     \"bar\"\n  //\n  before: function (original, cb) {\n    var __orig = this[original];\n    this[original] = function () {\n      cb.call(this);\n      __orig.apply(this, arguments);\n    };\n  },\n  \n  //\n  // `around` takes the name of a function and a callback and will invoke the\n  // callback passing a partially applied version of the original as the first argument.\n  // \n  //     var foo = { bar: function () { console.log('bar') } };\n  //     foo.around('bar', function (yield) {\n  //       console.log('before bar');\n  //       yield();\n  //       console.log('after bar');\n  //     });\n  //     \n  //     foo.bar(); //=> \"before bar\"\n  //                     \"bar\"\n  //                     \"after bar\"\n  //\n  //\n  around: function (original, cb) {\n    var __orig = this[original];\n    this[original] = function () {\n      var args = arguments;\n      cb.call(this, function () { return __orig.apply(this, args); }.bind(this));\n    };\n  },\n  \n  //\n  // `after` takes the name of a function and a callback and will invoke the\n  // callback after the original method is invoked.\n  // \n  //     var foo = { bar: function () { console.log('bar') } };\n  //     foo.after('bar', function () { console.log('after bar') });\n  //     \n  //     foo.bar(); //=> \"bar\"\n  //                     \"after bar\"\n  //\n  after: function (original, cb) {\n    var __orig = this[original];\n    this[original] = function () {\n      __orig.apply(this, arguments);\n      cb.call(this);\n    };\n  },\n  \n  //\n  // `subscribe` takes the name of a property and a callback function to invoke\n  // whenever it changes. It delegates to ko.obsarvable's subscribe method.\n  // \n  //     MyObj.subscribe('foo', function () { ... });\n  //\n  subscribe: function (name, fn) {\n    this[\"_\" + name].subscribe(fn);\n  },\n  \n  //\n  // `toString` returns a textual representation of your objects.\n  // It tries it's best to provide as detailed information as possible, including the objects type and attributes.\n  //\n  //     Serenity.Object.toString()\n  //           //=> <Serenity.Object @extend=\"method\" @set=\"method\" ...>\n  //\n  toString: function () {\n    var str = \"<\" + this.type + \" \";\n    this.forEach(function (slot) { \n      str += '@' + slot + '=';\n      str += typeof this[slot] === \"function\" ? '\"method\"' : '\"' + this[slot] + '\"';\n      str += \" \";\n    });\n    return str.trim() + \">\";\n  }\n};\n\nmodule.exports = _Object;\n//@ sourceURL=lib/serenity/object.js\n});");

// module: lib/serenity/enumerable
// file:   lib/serenity/enumerable.js
eval("define(\"lib/serenity/enumerable\", function(require, exports, module) { var        _ = require('../../vendor/underscore')\n  , Serenity = { Object: require('./object') };\n\n//\n// **Serenity.Enumerable** brings the underscore.js enumerable methods to your own objects.\n//\nvar Enumerable = Serenity.Object.clone(function () {\n  var toFn  = function (iterator) { return iterator.lambda ? iterator.lambda() : iterator; },\n      toCtx = function (ctx)      { return typeof ctx === 'function' ? ctx() : ctx;        };\n\n  //\n  // `each` applies the iterator for it's side-effects for every element in the collection.\n  //\n  this.each = function (iterator, ctx) {\n    return _.each(toCtx(this), toFn(iterator), ctx);\n  };\n\n  //\n  // `map` returns the result of applying the iterator to each element in the collection.\n  //\n  this.map = function (iterator, ctx) {\n    return _.map(toCtx(this), toFn(iterator), ctx);\n  };\n\n  //\n  // `reduce` builds up a single result from a list of values\n  //\n  this.reduce = function (iterator, memo, ctx) {\n    return _.reduce(toCtx(this), toFn(iterator), memo, ctx);\n  };\n\n  //\n  // `reduceRight` the right-associative version of reduce\n  //\n  this.reduceRight = function (iterator, memo, ctx) {\n    return _.reduceRight(toCtx(this), toFn(iterator), memo, ctx);\n  };\n\n  //\n  // `find` returns the first value which passes a truth test\n  //\n  this.find = function (iterator, ctx) {\n    return _.find(toCtx(this), toFn(iterator), ctx);\n  };\n\n  //\n  // `filter` returns all the elements that pass a truth test\n  //\n  this.filter = function (iterator, ctx) {\n    return _.filter(toCtx(this), toFn(iterator), ctx);\n  };\n\n  //\n  // `reject` returns all the elements for which a truth test fails\n  //\n  this.reject = function (iterator, ctx) {\n    return _.reject(toCtx(this), toFn(iterator), ctx);\n  };\n\n  //\n  // `every` determines wheter all of the elements match a truth test.\n  //\n  this.every = function (iterator, ctx) {\n    return _.every(toCtx(this), toFn(iterator), ctx);\n  };\n\n  //\n  // `every` determines if at least one of the elements match a truth test.\n  //\n  this.some = function (iterator, ctx) {\n    return _.some(toCtx(this), toFn(iterator), ctx);\n  };\n\n  //\n  // `contains` determines if a given value is included in the array or object using ===.\n  //\n  this.contains = function (value) {\n    return _.contains(toCtx(this), value);\n  };\n\n  //\n  // `invoke` invokes a method (with arguments) on every item in a collection.\n  //\n  this.invoke = function (method) {\n    return _.invoke.apply(_, [toCtx(this), method].concat(_.toArray(arguments).slice(1)));\n  };\n\n  //\n  // `pluck` is a convenience version of a common use case of map: fetching a property.\n  //\n  this.pluck = function (key) {\n    return _.pluck(toCtx(this), key);\n  };\n\n  //\n  // `max` returns the maximum element or (element-based computation)\n  //\n  this.max = function (iterator, ctx) {\n    return _.max(toCtx(this), toFn(iterator), ctx);\n  };\n\n  //\n  // `min` returns the minimum element or (element-based computation)\n  //\n  this.min = function (iterator, ctx) {\n    return _.min(toCtx(this), toFn(iterator), ctx);\n  };\n\n  //\n  // `shuffle` shuffles an array using Fisher-Yates in-place O(n) shuffle\n  // (implementation taken from: http://bost.ocks.org/mike/shuffle/)\n  //\n  this.shuffle = function () {\n    var array = toCtx(this);\n    var m = array.length, t, i;\n\n    // While there remain elements to shuffle…\n    while (m) {\n\n      // Pick a remaining element…\n      i = Math.floor(Math.random() * m--);\n\n      // And swap it with the current element.\n      t = array[m];\n      array[m] = array[i];\n      array[i] = t;\n    }\n\n    return array;\n  };\n\n  //\n  // `sortBy` sorts the collections values by a criterion produced by an iterator.\n  //\n  this.sortBy = function (iterator, ctx) {\n    return _.sortBy(toCtx(this), toFn(iterator), ctx);\n  };\n\n  //\n  // `groupBy` groups the objects values by a criterion.\n  //\n  this.groupBy = function (iterator) {\n    return _.groupBy(toCtx(this), toFn(iterator));\n  };\n\n  //\n  // `sortedIndex` uses a comparator function to figure out at what index an\n  // object should be inserted so as to maintain order. Uses binary search.\n  //\n  this.sortedIndex = function (obj, iterator) {\n    return _.groupBy(toCtx(this), obj, toFn(iterator));\n  };\n\n  //\n  // `length` returns the number of elements in the collection.\n  //\n  this.length = function () {\n    return toCtx(this).length;\n  };\n\n  //\n  // `first` returns the first element of an array. Passing ***n** will return the first N values in the array.\n  // The ***guard*** check allows it to work with map.\n  //\n  this.first = function (n, guard) {\n    return _.first(toCtx(this), n, guard);\n  };\n\n  //\n  // `initial` returns everything but the last element of an array. Passing ***n** will return all the values in\n  // the array, excluding the last N. The ***guard*** check allows it to work with map.\n  //\n  this.initial = function (n, guard) {\n    return _.initial(toCtx(this), n, guard);\n  };\n\n  //\n  // `last` returns the last element of an array. Passing ***n** will return the last N values in the array.\n  // The ***guard*** check allows it to work with map.\n  //\n  this.last = function (n, guard) {\n    return _.last(toCtx(this), n, guard);\n  };\n\n  //\n  // `rest` returns everything but the first element of an array. Passing ***n** will return all the values in\n  // the array, starting from N. The ***guard*** check allows it to work with map.\n  //\n  this.rest = function (n, guard) {\n    return _.rest(toCtx(this), n, guard);\n  };\n\n  //\n  // `compact` filters out all falsy values from an array\n  //\n  this.compact = function () {\n    return _.compact(toCtx(this));\n  };\n\n  //\n  // `flatten` returns a completely flattened version of an array.\n  //\n  this.flatten = function (shallow) {\n    return _.flatten(toCtx(this), shallow);\n  };\n\n  //\n  // `without` return a version of the array that does not contain the specified value(s).\n  //\n  this.without = function () {\n    return _.without.apply(_, [toCtx(this)].concat(_.toArray(arguments)));\n  };\n\n  //\n  // `unique` produces a duplicate-free version of the array. If the array has already been sorted\n  // you have the option of using a faster algorithm.\n  //\n  this.unique = function (isSorted, iterator) {\n    return _.unique(toCtx(this), isSorted, iterator);\n  };\n\n  //\n  // `union` produces an array that contains the union: each distinct element from all of the passed in arrays\n  //\n  this.union = function () {\n    return _.union.apply(_, [toCtx(this)].concat(_.toArray(arguments)));\n  };\n\n  //\n  // `intersection` produces an array that contains every item shared between all the passed in arrays.\n  //\n  this.intersection = function () {\n    return _.intersection.apply(_, [toCtx(this)].concat(_.toArray(arguments)));\n  };\n\n  //\n  // `difference` takes the difference between one array and a number of other arrays.\n  // Only the elements present in the receiver will remain.\n  //\n  this.difference = function () {\n    return _.difference.apply(_, [toCtx(this)].concat(_.toArray(arguments)));\n  };\n\n  //\n  // `zip` zips together multiple lists into a single array -- elements that share an index go together.\n  //\n  this.zip = function () {\n    return _.zip.apply(_, [toCtx(this)].concat(_.toArray(arguments)));\n  };\n\n  //\n  // `indexOf` returns the index of an element in the array or -1 if it's not present.\n  //\n  this.indexOf = function (item, isSorted) {\n    return _.indexOf(toCtx(this), item, isSorted);\n  };\n\n  this.lastIndexOf = function (item) {\n    return _.lastIndexOf(toCtx(this), item);\n  };\n  /*\n  this.remove = function (item) {\n    var self = toCtx(this);\n    self.splice(self.indexOf(item), 1);\n    return self;\n  };\n  */\n});\n\nmodule.exports = Enumerable;\n//@ sourceURL=lib/serenity/enumerable.js\n});");

// module: vendor/string-lambda
// file:   vendor/string-lambda.js
eval("define(\"vendor/string-lambda\", function(require, exports, module) { /*\n * Author: Oliver Steele\n * Copyright: Copyright 2007 by Oliver Steele.  All rights reserved.\n * License: MIT License\n * Homepage: http://osteele.com/javascripts/functional\n * Created: 2007-07-11\n * Version: 1.0.2\n *\n *\n * This defines \"string lambdas\", that allow strings such as `x+1` and\n * `x -> x+1` to be used in some contexts as functions.\n */\n\n\n/// ^ String lambdas\n\n/**\n * Turns a string that contains a JavaScript expression into a\n * `Function` that returns the value of that expression.\n *\n * If the string contains a `->`, this separates the parameters from the body:\n * >> 'x -> x + 1'.lambda()(1) -> 2\n * >> 'x y -> x + 2*y'.lambda()(1, 2) -> 5\n * >> 'x, y -> x + 2*y'.lambda()(1, 2) -> 5\n *\n * Otherwise, if the string contains a `_`, this is the parameter:\n * >> '_ + 1'.lambda()(1) -> 2\n *\n * Otherwise if the string begins or ends with an operator or relation,\n * prepend or append a parameter.  (The documentation refers to this type\n * of string as a \"section\".)\n * >> '/2'.lambda()(4) -> 2\n * >> '2/'.lambda()(4) -> 0.5\n * >> '/'.lambda()(2,4) -> 0.5\n * Sections can end, but not begin with, `-`.  (This is to avoid interpreting\n * e.g. `-2*x` as a section).  On the other hand, a string that either begins\n * or ends with `/` is a section, so an expression that begins or ends with a\n * regular expression literal needs an explicit parameter.\n *\n * Otherwise, each variable name is an implicit parameter:\n * >> 'x + 1'.lambda()(1) -> 2\n * >> 'x + 2*y'.lambda()(1, 2) -> 5\n * >> 'y + 2*x'.lambda()(1, 2) -> 5\n *\n * Implicit parameter detection ignores strings literals, variable names that\n * start with capitals, and identifiers that precede `:` or follow `.`:\n * >> map('\"im\"+root', [\"probable\", \"possible\"]) -> [\"improbable\", \"impossible\"]\n * >> 'Math.cos(angle)'.lambda()(Math.PI) -> -1\n * >> 'point.x'.lambda()({x:1, y:2}) -> 1\n * >> '({x:1, y:2})[key]'.lambda()('x') -> 1\n *\n * Implicit parameter detection mistakenly looks inside regular expression\n * literals for variable names.  It also doesn't know to ignore JavaScript\n * keywords and bound variables.  (The only way you can get these last two is\n * with a function literal inside the string.  This is outside the intended use\n * case for string lambdas.)\n *\n * Use `_` (to define a unary function) or `->`, if the string contains anything\n * that looks like a free variable but shouldn't be used as a parameter, or\n * to specify parameters that are ordered differently from their first\n * occurrence in the string.\n *\n * Chain `->`s to create a function in uncurried form:\n * >> 'x -> y -> x + 2*y'.lambda()(1)(2) -> 5\n * >> 'x -> y -> z -> x + 2*y+3*z'.lambda()(1)(2)(3) -> 14\n *\n * `this` and `arguments` are special:\n * >> 'this'.call(1) -> 1\n * >> '[].slice.call(arguments, 0)'.call(null,1,2) -> [1, 2]\n */\nString.prototype.lambda = function() {\n    var params = [],\n        expr = this,\n        sections = expr.ECMAsplit(/\\s*->\\s*/m);\n    if (sections.length > 1) {\n        while (sections.length) {\n            expr = sections.pop();\n            params = sections.pop().split(/\\s*,\\s*|\\s+/m);\n            sections.length && sections.push('(function('+params+'){return ('+expr+')})');\n        }\n    } else if (expr.match(/\\b_\\b/)) {\n        params = '_';\n    } else {\n        // test whether an operator appears on the left (or right), respectively\n        var leftSection = expr.match(/^\\s*(?:[+*\\/%&|\\^\\.=<>]|!=)/m),\n            rightSection = expr.match(/[+\\-*\\/%&|\\^\\.=<>!]\\s*$/m);\n        if (leftSection || rightSection) {\n            if (leftSection) {\n                params.push('$1');\n                expr = '$1' + expr;\n            }\n            if (rightSection) {\n                params.push('$2');\n                expr = expr + '$2';\n            }\n        } else {\n            // `replace` removes symbols that are capitalized, follow '.',\n            // precede ':', are 'this' or 'arguments'; and also the insides of\n            // strings (by a crude test).  `match` extracts the remaining\n            // symbols.\n            var vars = this.replace(/(?:\\b[A-Z]|\\.[a-zA-Z_$])[a-zA-Z_$\\d]*|[a-zA-Z_$][a-zA-Z_$\\d]*\\s*:|this|arguments|'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"/g, '').match(/([a-z_$][a-z_$\\d]*)/gi) || []; // '\n            for (var i = 0, v; v = vars[i++]; )\n                params.indexOf(v) >= 0 || params.push(v);\n        }\n    }\n    return new Function(params, 'return (' + expr + ')');\n}\n\n/// Turn on caching for `string` -> `Function` conversion.\nString.prototype.lambda.cache = function() {\n    var proto = String.prototype,\n        cache = {},\n        uncached = proto.lambda,\n        cached = function() {\n	        var key = '#' + this; // avoid hidden properties on Object.prototype\n	        return cache[key] || (cache[key] = uncached.call(this));\n        };\n    cached.cached = function(){};\n    cached.uncache = function(){proto.lambda = uncached};\n    proto.lambda = cached;\n}\n\n/**\n * ^^ Duck-Typing\n *\n * Strings support `call` and `apply`.  This duck-types them as\n * functions, to some callers.\n */\n\n/**\n * Coerce the string to a function and then apply it.\n * >> 'x+1'.apply(null, [2]) -> 3\n * >> '/'.apply(null, [2, 4]) -> 0.5\n */\nString.prototype.apply = function(thisArg, args) {\n    return this.toFunction().apply(thisArg, args);\n}\n\n/**\n * Coerce the string to a function and then call it.\n * >> 'x+1'.call(null, 2) -> 3\n * >> '/'.call(null, 2, 4) -> 0.5\n */\nString.prototype.call = function() {\n    return this.toFunction().apply(arguments[0],\n                                   Array.prototype.slice.call(arguments, 1));\n}\n\n/// ^^ Coercion\n\n/**\n * Returns a `Function` that perfoms the action described by this\n * string.  If the string contains a `return`, applies\n * `new Function` to it.  Otherwise, this function returns\n *  the result of `this.lambda()`.\n * >> '+1'.toFunction()(2) -> 3\n * >> 'return 1'.toFunction()(1) -> 1\n */\nString.prototype.toFunction = function() {\n    var body = this;\n    if (body.match(/\\breturn\\b/))\n        return new Function(this);\n    return this.lambda();\n}\n\n/**\n * Returns this function.  `Function.toFunction` calls this.\n * >> '+1'.lambda().toFunction()(2) -> 3\n */\nFunction.prototype.toFunction = function() {\n    return this;\n}\n\n/**\n * Coerces `fn` into a function if it is not already one,\n * by calling its `toFunction` method.\n * >> Function.toFunction(function() {return 1})() -> 1\n * >> Function.toFunction('+1')(2) -> 3\n *\n * `Function.toFunction` requires an argument that can be\n * coerced to a function.  A nullary version can be\n * constructed via `guard`:\n * >> Function.toFunction.guard()('1+') -> function()\n * >> Function.toFunction.guard()(null) -> null\n *\n * `Function.toFunction` doesn't coerce arbitrary values to functions.\n * It might seem convenient to treat\n * `Function.toFunction(value)` as though it were the\n * constant function that returned `value`, but it's rarely\n * useful and it hides errors.  Use `Functional.K(value)` instead,\n * or a lambda string when the value is a compile-time literal:\n * >> Functional.K('a string')() -> \"a string\"\n * >> Function.toFunction('\"a string\"')() -> \"a string\"\n */\nFunction.toFunction = function(value) {\n    return value.toFunction();\n}\n\n// Utilities\n\n// IE6 split is not ECMAScript-compliant.  This breaks '->1'.lambda().\n// ECMAsplit is an ECMAScript-compliant `split`, although only for\n// one argument.\nString.prototype.ECMAsplit =\n    // The test is from the ECMAScript reference.\n    ('ab'.split(/a*/).length > 1\n     ? String.prototype.split\n     : function(separator, limit) {\n         if (typeof limit != 'undefined')\n             throw \"ECMAsplit: limit is unimplemented\";\n         var result = this.split.apply(this, arguments),\n             re = RegExp(separator),\n             savedIndex = re.lastIndex,\n             match = re.exec(this);\n         if (match && match.index == 0)\n             result.unshift('');\n         // in case `separator` was already a RegExp:\n         re.lastIndex = savedIndex;\n         return result;\n     });\n//@ sourceURL=vendor/string-lambda.js\n});");

// module: vendor/underscore
// file:   vendor/underscore.js
eval("define(\"vendor/underscore\", function(require, exports, module) { // Underscore.js 1.3.1\n// (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n// Underscore is freely distributable under the MIT license.\n// Portions of Underscore are inspired or borrowed from Prototype,\n// Oliver Steele's Functional, and John Resig's Micro-Templating.\n// For all details and documentation:\n// http://documentcloud.github.com/underscore\n(function(){function q(a,c,d){if(a===c)return a!==0||1/a==1/c;if(a==null||c==null)return a===c;if(a._chain)a=a._wrapped;if(c._chain)c=c._wrapped;if(a.isEqual&&b.isFunction(a.isEqual))return a.isEqual(c);if(c.isEqual&&b.isFunction(c.isEqual))return c.isEqual(a);var e=l.call(a);if(e!=l.call(c))return false;switch(e){case \"[object String]\":return a==String(c);case \"[object Number]\":return a!=+a?c!=+c:a==0?1/a==1/c:a==+c;case \"[object Date]\":case \"[object Boolean]\":return+a==+c;case \"[object RegExp]\":return a.source==\nc.source&&a.global==c.global&&a.multiline==c.multiline&&a.ignoreCase==c.ignoreCase}if(typeof a!=\"object\"||typeof c!=\"object\")return false;for(var f=d.length;f--;)if(d[f]==a)return true;d.push(a);var f=0,g=true;if(e==\"[object Array]\"){if(f=a.length,g=f==c.length)for(;f--;)if(!(g=f in a==f in c&&q(a[f],c[f],d)))break}else{if(\"constructor\"in a!=\"constructor\"in c||a.constructor!=c.constructor)return false;for(var h in a)if(b.has(a,h)&&(f++,!(g=b.has(c,h)&&q(a[h],c[h],d))))break;if(g){for(h in c)if(b.has(c,\nh)&&!f--)break;g=!f}}d.pop();return g}var r=this,G=r._,n={},k=Array.prototype,o=Object.prototype,i=k.slice,H=k.unshift,l=o.toString,I=o.hasOwnProperty,w=k.forEach,x=k.map,y=k.reduce,z=k.reduceRight,A=k.filter,B=k.every,C=k.some,p=k.indexOf,D=k.lastIndexOf,o=Array.isArray,J=Object.keys,s=Function.prototype.bind,b=function(a){return new m(a)};if(typeof exports!==\"undefined\"){if(typeof module!==\"undefined\"&&module.exports)exports=module.exports=b;exports._=b}else r._=b;b.VERSION=\"1.3.1\";var j=b.each=\nb.forEach=function(a,c,d){if(a!=null)if(w&&a.forEach===w)a.forEach(c,d);else if(a.length===+a.length)for(var e=0,f=a.length;e<f;e++){if(e in a&&c.call(d,a[e],e,a)===n)break}else for(e in a)if(b.has(a,e)&&c.call(d,a[e],e,a)===n)break};b.map=b.collect=function(a,c,b){var e=[];if(a==null)return e;if(x&&a.map===x)return a.map(c,b);j(a,function(a,g,h){e[e.length]=c.call(b,a,g,h)});if(a.length===+a.length)e.length=a.length;return e};b.reduce=b.foldl=b.inject=function(a,c,d,e){var f=arguments.length>2;a==\nnull&&(a=[]);if(y&&a.reduce===y)return e&&(c=b.bind(c,e)),f?a.reduce(c,d):a.reduce(c);j(a,function(a,b,i){f?d=c.call(e,d,a,b,i):(d=a,f=true)});if(!f)throw new TypeError(\"Reduce of empty array with no initial value\");return d};b.reduceRight=b.foldr=function(a,c,d,e){var f=arguments.length>2;a==null&&(a=[]);if(z&&a.reduceRight===z)return e&&(c=b.bind(c,e)),f?a.reduceRight(c,d):a.reduceRight(c);var g=b.toArray(a).reverse();e&&!f&&(c=b.bind(c,e));return f?b.reduce(g,c,d,e):b.reduce(g,c)};b.find=b.detect=\nfunction(a,c,b){var e;E(a,function(a,g,h){if(c.call(b,a,g,h))return e=a,true});return e};b.filter=b.select=function(a,c,b){var e=[];if(a==null)return e;if(A&&a.filter===A)return a.filter(c,b);j(a,function(a,g,h){c.call(b,a,g,h)&&(e[e.length]=a)});return e};b.reject=function(a,c,b){var e=[];if(a==null)return e;j(a,function(a,g,h){c.call(b,a,g,h)||(e[e.length]=a)});return e};b.every=b.all=function(a,c,b){var e=true;if(a==null)return e;if(B&&a.every===B)return a.every(c,b);j(a,function(a,g,h){if(!(e=\ne&&c.call(b,a,g,h)))return n});return e};var E=b.some=b.any=function(a,c,d){c||(c=b.identity);var e=false;if(a==null)return e;if(C&&a.some===C)return a.some(c,d);j(a,function(a,b,h){if(e||(e=c.call(d,a,b,h)))return n});return!!e};b.include=b.contains=function(a,c){var b=false;if(a==null)return b;return p&&a.indexOf===p?a.indexOf(c)!=-1:b=E(a,function(a){return a===c})};b.invoke=function(a,c){var d=i.call(arguments,2);return b.map(a,function(a){return(b.isFunction(c)?c||a:a[c]).apply(a,d)})};b.pluck=\nfunction(a,c){return b.map(a,function(a){return a[c]})};b.max=function(a,c,d){if(!c&&b.isArray(a))return Math.max.apply(Math,a);if(!c&&b.isEmpty(a))return-Infinity;var e={computed:-Infinity};j(a,function(a,b,h){b=c?c.call(d,a,b,h):a;b>=e.computed&&(e={value:a,computed:b})});return e.value};b.min=function(a,c,d){if(!c&&b.isArray(a))return Math.min.apply(Math,a);if(!c&&b.isEmpty(a))return Infinity;var e={computed:Infinity};j(a,function(a,b,h){b=c?c.call(d,a,b,h):a;b<e.computed&&(e={value:a,computed:b})});\nreturn e.value};b.shuffle=function(a){var b=[],d;j(a,function(a,f){f==0?b[0]=a:(d=Math.floor(Math.random()*(f+1)),b[f]=b[d],b[d]=a)});return b};b.sortBy=function(a,c,d){return b.pluck(b.map(a,function(a,b,g){return{value:a,criteria:c.call(d,a,b,g)}}).sort(function(a,b){var c=a.criteria,d=b.criteria;return c<d?-1:c>d?1:0}),\"value\")};b.groupBy=function(a,c){var d={},e=b.isFunction(c)?c:function(a){return a[c]};j(a,function(a,b){var c=e(a,b);(d[c]||(d[c]=[])).push(a)});return d};b.sortedIndex=function(a,\nc,d){d||(d=b.identity);for(var e=0,f=a.length;e<f;){var g=e+f>>1;d(a[g])<d(c)?e=g+1:f=g}return e};b.toArray=function(a){return!a?[]:a.toArray?a.toArray():b.isArray(a)?i.call(a):b.isArguments(a)?i.call(a):b.values(a)};b.size=function(a){return b.toArray(a).length};b.first=b.head=function(a,b,d){return b!=null&&!d?i.call(a,0,b):a[0]};b.initial=function(a,b,d){return i.call(a,0,a.length-(b==null||d?1:b))};b.last=function(a,b,d){return b!=null&&!d?i.call(a,Math.max(a.length-b,0)):a[a.length-1]};b.rest=\nb.tail=function(a,b,d){return i.call(a,b==null||d?1:b)};b.compact=function(a){return b.filter(a,function(a){return!!a})};b.flatten=function(a,c){return b.reduce(a,function(a,e){if(b.isArray(e))return a.concat(c?e:b.flatten(e));a[a.length]=e;return a},[])};b.without=function(a){return b.difference(a,i.call(arguments,1))};b.uniq=b.unique=function(a,c,d){var d=d?b.map(a,d):a,e=[];b.reduce(d,function(d,g,h){if(0==h||(c===true?b.last(d)!=g:!b.include(d,g)))d[d.length]=g,e[e.length]=a[h];return d},[]);\nreturn e};b.union=function(){return b.uniq(b.flatten(arguments,true))};b.intersection=b.intersect=function(a){var c=i.call(arguments,1);return b.filter(b.uniq(a),function(a){return b.every(c,function(c){return b.indexOf(c,a)>=0})})};b.difference=function(a){var c=b.flatten(i.call(arguments,1));return b.filter(a,function(a){return!b.include(c,a)})};b.zip=function(){for(var a=i.call(arguments),c=b.max(b.pluck(a,\"length\")),d=Array(c),e=0;e<c;e++)d[e]=b.pluck(a,\"\"+e);return d};b.indexOf=function(a,c,\nd){if(a==null)return-1;var e;if(d)return d=b.sortedIndex(a,c),a[d]===c?d:-1;if(p&&a.indexOf===p)return a.indexOf(c);for(d=0,e=a.length;d<e;d++)if(d in a&&a[d]===c)return d;return-1};b.lastIndexOf=function(a,b){if(a==null)return-1;if(D&&a.lastIndexOf===D)return a.lastIndexOf(b);for(var d=a.length;d--;)if(d in a&&a[d]===b)return d;return-1};b.range=function(a,b,d){arguments.length<=1&&(b=a||0,a=0);for(var d=arguments[2]||1,e=Math.max(Math.ceil((b-a)/d),0),f=0,g=Array(e);f<e;)g[f++]=a,a+=d;return g};\nvar F=function(){};b.bind=function(a,c){var d,e;if(a.bind===s&&s)return s.apply(a,i.call(arguments,1));if(!b.isFunction(a))throw new TypeError;e=i.call(arguments,2);return d=function(){if(!(this instanceof d))return a.apply(c,e.concat(i.call(arguments)));F.prototype=a.prototype;var b=new F,g=a.apply(b,e.concat(i.call(arguments)));return Object(g)===g?g:b}};b.bindAll=function(a){var c=i.call(arguments,1);c.length==0&&(c=b.functions(a));j(c,function(c){a[c]=b.bind(a[c],a)});return a};b.memoize=function(a,\nc){var d={};c||(c=b.identity);return function(){var e=c.apply(this,arguments);return b.has(d,e)?d[e]:d[e]=a.apply(this,arguments)}};b.delay=function(a,b){var d=i.call(arguments,2);return setTimeout(function(){return a.apply(a,d)},b)};b.defer=function(a){return b.delay.apply(b,[a,1].concat(i.call(arguments,1)))};b.throttle=function(a,c){var d,e,f,g,h,i=b.debounce(function(){h=g=false},c);return function(){d=this;e=arguments;var b;f||(f=setTimeout(function(){f=null;h&&a.apply(d,e);i()},c));g?h=true:\na.apply(d,e);i();g=true}};b.debounce=function(a,b){var d;return function(){var e=this,f=arguments;clearTimeout(d);d=setTimeout(function(){d=null;a.apply(e,f)},b)}};b.once=function(a){var b=false,d;return function(){if(b)return d;b=true;return d=a.apply(this,arguments)}};b.wrap=function(a,b){return function(){var d=[a].concat(i.call(arguments,0));return b.apply(this,d)}};b.compose=function(){var a=arguments;return function(){for(var b=arguments,d=a.length-1;d>=0;d--)b=[a[d].apply(this,b)];return b[0]}};\nb.after=function(a,b){return a<=0?b():function(){if(--a<1)return b.apply(this,arguments)}};b.keys=J||function(a){if(a!==Object(a))throw new TypeError(\"Invalid object\");var c=[],d;for(d in a)b.has(a,d)&&(c[c.length]=d);return c};b.values=function(a){return b.map(a,b.identity)};b.functions=b.methods=function(a){var c=[],d;for(d in a)b.isFunction(a[d])&&c.push(d);return c.sort()};b.extend=function(a){j(i.call(arguments,1),function(b){for(var d in b)a[d]=b[d]});return a};b.defaults=function(a){j(i.call(arguments,\n1),function(b){for(var d in b)a[d]==null&&(a[d]=b[d])});return a};b.clone=function(a){return!b.isObject(a)?a:b.isArray(a)?a.slice():b.extend({},a)};b.tap=function(a,b){b(a);return a};b.isEqual=function(a,b){return q(a,b,[])};b.isEmpty=function(a){if(b.isArray(a)||b.isString(a))return a.length===0;for(var c in a)if(b.has(a,c))return false;return true};b.isElement=function(a){return!!(a&&a.nodeType==1)};b.isArray=o||function(a){return l.call(a)==\"[object Array]\"};b.isObject=function(a){return a===Object(a)};\nb.isArguments=function(a){return l.call(a)==\"[object Arguments]\"};if(!b.isArguments(arguments))b.isArguments=function(a){return!(!a||!b.has(a,\"callee\"))};b.isFunction=function(a){return l.call(a)==\"[object Function]\"};b.isString=function(a){return l.call(a)==\"[object String]\"};b.isNumber=function(a){return l.call(a)==\"[object Number]\"};b.isNaN=function(a){return a!==a};b.isBoolean=function(a){return a===true||a===false||l.call(a)==\"[object Boolean]\"};b.isDate=function(a){return l.call(a)==\"[object Date]\"};\nb.isRegExp=function(a){return l.call(a)==\"[object RegExp]\"};b.isNull=function(a){return a===null};b.isUndefined=function(a){return a===void 0};b.has=function(a,b){return I.call(a,b)};b.noConflict=function(){r._=G;return this};b.identity=function(a){return a};b.times=function(a,b,d){for(var e=0;e<a;e++)b.call(d,e)};b.escape=function(a){return(\"\"+a).replace(/&/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\").replace(/\"/g,\"&quot;\").replace(/'/g,\"&#x27;\").replace(/\\//g,\"&#x2F;\")};b.mixin=function(a){j(b.functions(a),\nfunction(c){K(c,b[c]=a[c])})};var L=0;b.uniqueId=function(a){var b=L++;return a?a+b:b};b.templateSettings={evaluate:/<%([\\s\\S]+?)%>/g,interpolate:/<%=([\\s\\S]+?)%>/g,escape:/<%-([\\s\\S]+?)%>/g};var t=/.^/,u=function(a){return a.replace(/\\\\\\\\/g,\"\\\\\").replace(/\\\\'/g,\"'\")};b.template=function(a,c){var d=b.templateSettings,d=\"var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('\"+a.replace(/\\\\/g,\"\\\\\\\\\").replace(/'/g,\"\\\\'\").replace(d.escape||t,function(a,b){return\"',_.escape(\"+\nu(b)+\"),'\"}).replace(d.interpolate||t,function(a,b){return\"',\"+u(b)+\",'\"}).replace(d.evaluate||t,function(a,b){return\"');\"+u(b).replace(/[\\r\\n\\t]/g,\" \")+\";__p.push('\"}).replace(/\\r/g,\"\\\\r\").replace(/\\n/g,\"\\\\n\").replace(/\\t/g,\"\\\\t\")+\"');}return __p.join('');\",e=new Function(\"obj\",\"_\",d);return c?e(c,b):function(a){return e.call(this,a,b)}};b.chain=function(a){return b(a).chain()};var m=function(a){this._wrapped=a};b.prototype=m.prototype;var v=function(a,c){return c?b(a).chain():a},K=function(a,c){m.prototype[a]=\nfunction(){var a=i.call(arguments);H.call(a,this._wrapped);return v(c.apply(b,a),this._chain)}};b.mixin(b);j(\"pop,push,reverse,shift,sort,splice,unshift\".split(\",\"),function(a){var b=k[a];m.prototype[a]=function(){var d=this._wrapped;b.apply(d,arguments);var e=d.length;(a==\"shift\"||a==\"splice\")&&e===0&&delete d[0];return v(d,this._chain)}});j([\"concat\",\"join\",\"slice\"],function(a){var b=k[a];m.prototype[a]=function(){return v(b.apply(this._wrapped,arguments),this._chain)}});m.prototype.chain=function(){this._chain=\ntrue;return this};m.prototype.value=function(){return this._wrapped}}).call(this);\n\n//@ sourceURL=vendor/underscore.js\n});");

// module: vendor/jquery-transition
// file:   vendor/jquery-transition.js
eval("define(\"vendor/jquery-transition\", function(require, exports, module) { /* Cases where transition is disabled:\n * - in incompatible browsers (Opera 11 included)\n * - when the animated object is not an element\n * - when there is a special easing\n * - when there is a step function\n * - when jQuery.fx.off is true (should work out of the box)\n *\n * jQuery.fx.stop() will stop animations instead of pausing them (undocumented method and behavior anyway).\n */\n(function( jQuery ) {\n\nvar elemdisplay = {},\n	iframe, iframeDoc,\n	rfxtypes = /^(?:toggle|show|hide)$/,\n	rfxnum = /^([+\\-]=)?([\\d+.\\-]+)([a-z%]*)$/i,\n	timerId,\n	/*fxAttrs = [\n		// height animations\n		[ \"height\", \"marginTop\", \"marginBottom\", \"paddingTop\", \"paddingBottom\" ],\n		// width animations\n		[ \"width\", \"marginLeft\", \"marginRight\", \"paddingLeft\", \"paddingRight\" ],\n		// opacity animations\n		[ \"opacity\" ]\n	],*/\n	fxNow;\n\n// ++TRANSITION++\n// Following feature test code should be moved to support.js\nvar div = document.createElement( \"div\" ),\n	divStyle = div.style,\n	trans = \"Transition\";\n// Only test for transition support in Firefox and Webkit\n// as we know for sure that Opera has too much bugs (see http://csstransition.net)\n// and there's no guarantee that first IE implementation will be bug-free\njQuery.support.transition =\n	\"Moz\"+trans in divStyle ? \"Moz\"+trans:\n	\"Webkit\"+trans in divStyle ? \"Webkit\"+trans:\n	false;\n\njQuery.fn.extend({\n	/*show: function( speed, easing, callback ) {\n		var elem, display;\n\n		if ( speed || speed === 0 ) {\n			return this.animate( genFx(\"show\", 3), speed, easing, callback );\n\n		} else {\n			for ( var i = 0, j = this.length; i < j; i++ ) {\n				elem = this[ i ];\n\n				if ( elem.style ) {\n					display = elem.style.display;\n\n					// Reset the inline display of this element to learn if it is\n					// being hidden by cascaded rules or not\n					if ( !jQuery._data(elem, \"olddisplay\") && display === \"none\" ) {\n						display = elem.style.display = \"\";\n					}\n\n					// Set elements which have been overridden with display: none\n					// in a stylesheet to whatever the default browser style is\n					// for such an element\n					if ( (display === \"\" && jQuery.css(elem, \"display\") === \"none\") ||\n						!jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {\n						jQuery._data( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n					}\n				}\n			}\n\n			// Set the display of most of the elements in a second loop\n			// to avoid the constant reflow\n			for ( i = 0; i < j; i++ ) {\n				elem = this[ i ];\n\n				if ( elem.style ) {\n					display = elem.style.display;\n\n					if ( display === \"\" || display === \"none\" ) {\n						elem.style.display = jQuery._data( elem, \"olddisplay\" ) || \"\";\n					}\n				}\n			}\n\n			return this;\n		}\n	},\n\n	hide: function( speed, easing, callback ) {\n		if ( speed || speed === 0 ) {\n			return this.animate( genFx(\"hide\", 3), speed, easing, callback);\n\n		} else {\n			var elem, display,\n				i = 0,\n				j = this.length;\n\n			for ( ; i < j; i++ ) {\n				elem = this[i];\n				if ( elem.style ) {\n					display = jQuery.css( elem, \"display\" );\n\n					if ( display !== \"none\" && !jQuery._data( elem, \"olddisplay\" ) ) {\n						jQuery._data( elem, \"olddisplay\", display );\n					}\n				}\n			}\n\n			// Set the display of the elements in a second loop\n			// to avoid the constant reflow\n			for ( i = 0; i < j; i++ ) {\n				if ( this[i].style ) {\n					this[i].style.display = \"none\";\n				}\n			}\n\n			return this;\n		}\n	},\n\n	// Save the old toggle function\n	_toggle: jQuery.fn.toggle,\n\n	toggle: function( fn, fn2, callback ) {\n		var bool = typeof fn === \"boolean\";\n\n		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {\n			this._toggle.apply( this, arguments );\n\n		} else if ( fn == null || bool ) {\n			this.each(function() {\n				var state = bool ? fn : jQuery(this).is(\":hidden\");\n				jQuery(this)[ state ? \"show\" : \"hide\" ]();\n			});\n\n		} else {\n			this.animate(genFx(\"toggle\", 3), fn, fn2, callback);\n		}\n\n		return this;\n	},\n\n	fadeTo: function( speed, to, easing, callback ) {\n		return this.filter(\":hidden\").css(\"opacity\", 0).show().end()\n					.animate({opacity: to}, speed, easing, callback);\n	},*/\n\n	animate: function( prop, speed, easing, callback ) {\n		var optall = jQuery.speed( speed, easing, callback );\n\n		if ( jQuery.isEmptyObject( prop ) ) {\n			return this.each( optall.complete, [ false ] );\n		}\n\n		// Do not change referenced properties as per-property easing will be lost\n		prop = jQuery.extend( {}, prop );\n\n		function doAnimation() {\n			// XXX 'this' does not always have a nodeName when running the\n			// test suite\n\n			if ( optall.queue === false ) {\n				jQuery._mark( this );\n			}\n\n			var opt = jQuery.extend( {}, optall ),\n				isElement = this.nodeType === 1,\n				hidden = isElement && jQuery(this).is(\":hidden\"),\n				name, val, p, e, hooks, replace,\n				parts, start, end, unit,\n				method,\n				// ++TRANSITION++\n				cssProps = jQuery.cssProps,\n				// disable transition if a step option is supplied\n				supportTransition = !opt.step && jQuery.support.transition,\n				transition,\n				transitions = [],\n				easing, real, lower;\n\n			// will store per property easing and be used to determine when an animation is complete\n			opt.animatedProperties = {};\n			// ++TRANSITION++\n			// transition is enabled per property, when:\n			// - there is no step function for the animation\n			// - there is no special easing for the property\n			opt.transition = {};\n\n			// first pass over propertys to expand / normalize\n			for ( p in prop ) {\n				name = jQuery.camelCase( p );\n				if ( p !== name ) {\n					prop[ name ] = prop[ p ];\n					delete prop[ p ];\n				}\n\n				if ( ( hooks = jQuery.cssHooks[ name ] ) && \"expand\" in hooks ) {\n					replace = hooks.expand( prop[ name ] );\n					delete prop[ name ];\n\n					// not quite $.extend, this wont overwrite keys already present.\n					// also - reusing 'p' from above because we have the correct \"name\"\n					for ( p in replace ) {\n						if ( ! ( p in prop ) ) {\n							prop[ p ] = replace[ p ];\n						}\n					}\n				}\n			}\n\n			for ( name in prop ) {\n				val = prop[ name ];\n				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)\n				if ( jQuery.isArray( val ) ) {\n					/* ++TRANSITION++ */ easing = opt.animatedProperties[ name ] = val[ 1 ];\n					val = prop[ name ] = val[ 0 ];\n				} else {\n					/* ++TRANSITION++ */ easing = opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';\n				}\n\n				// ++TRANSITION++\n				// check that CSS Transitions can be used\n				transition = supportTransition && isElement && opt.duration > 0 && name.indexOf(\"scroll\") && (\n					// we could use a hash to convert the names\n					easing == 'swing' ? 'ease':\n					easing == 'linear' ? easing:\n					false\n				);\n\n				// collect the properties to be added to elem.style.transition...\n				if ( transition ) {\n					real = cssProps[ name ] || name;\n\n					lower = real.replace(/([A-Z])/g, '-$1').toLowerCase();\n\n					transition =\n						lower +\" \"+\n						opt.duration +\"ms \"+\n						transition;\n\n					opt.transition[ name ] = {\n						lower: lower,\n						real: real\n					};\n\n					transitions.push(transition);\n				}\n\n				if ( val === \"hide\" && hidden || val === \"show\" && !hidden ) {\n					return opt.complete.call( this );\n				}\n\n				if ( isElement && ( name === \"height\" || name === \"width\" ) ) {\n					// Make sure that nothing sneaks out\n					// Record all 3 overflow attributes because IE does not\n					// change the overflow attribute when overflowX and\n					// overflowY are set to the same value\n					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];\n\n					// Set display property to inline-block for height/width\n					// animations on inline elements that are having width/height animated\n					if ( jQuery.css( this, \"display\" ) === \"inline\" &&\n							jQuery.css( this, \"float\" ) === \"none\" ) {\n\n						// inline-level elements accept inline-block;\n						// block-level elements need to be inline with layout\n						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === \"inline\" ) {\n							this.style.display = \"inline-block\";\n\n						} else {\n							this.style.zoom = 1;\n						}\n					}\n				}\n			}\n\n			if ( opt.overflow != null ) {\n				this.style.overflow = \"hidden\";\n			}\n\n			for ( p in prop ) {\n				e = new jQuery.fx( this, opt, p );\n				val = prop[ p ];\n\n				if ( rfxtypes.test( val ) ) {\n\n					// Tracks whether to show or hide based on private\n					// data attached to the element\n					method = jQuery._data( this, \"toggle\" + p ) || ( val === \"toggle\" ? hidden ? \"show\" : \"hide\" : 0 );\n					if ( method ) {\n						jQuery._data( this, \"toggle\" + p, method === \"show\" ? \"hide\" : \"show\" );\n						e[ method ]();\n					} else {\n						e[ val ]();\n					}\n\n				} else {\n					parts = rfxnum.exec( val );\n					start = e.cur();\n\n					if ( parts ) {\n						end = parseFloat( parts[2] );\n						unit = parts[3] || ( jQuery.cssNumber[ p ] ? \"\" : \"px\" );\n\n						// We need to compute starting value\n						if ( unit !== \"px\" ) {\n							jQuery.style( this, p, (end || 1) + unit);\n							start = ( (end || 1) / e.cur() ) * start;\n							jQuery.style( this, p, start + unit);\n						}\n\n						// If a +=/-= token was provided, we're doing a relative animation\n						if ( parts[1] ) {\n							end = ( (parts[ 1 ] === \"-=\" ? -1 : 1) * end ) + start;\n						}\n\n						e.custom( start, end, unit );\n\n					} else {\n						e.custom( start, val, \"\" );\n					}\n				}\n			}\n\n			// ++TRANSITION++\n			if ( supportTransition && transitions.length ) {\n				transition = this.style[supportTransition];\n				this.style[supportTransition] = transitions.join() + (transition ? ',' + transition : '');\n				// Once the transition property has been set, it's time to set all animated style properties\n				for ( p in opt.transition ) {\n					jQuery.style.apply( null, opt.transition[ p ].styleToSet );\n				}\n			}\n\n			// For JS strict compliance\n			return true;\n		}\n\n		return optall.queue === false ?\n			this.each( doAnimation ) :\n			this.queue( optall.queue, doAnimation );\n	},\n\n	stop: function( type, clearQueue, gotoEnd ) {\n		if ( typeof type !== \"string\" ) {\n			gotoEnd = clearQueue;\n			clearQueue = type;\n			type = undefined;\n		}\n		if ( clearQueue && type !== false ) {\n			this.queue( type || \"fx\", [] );\n		}\n\n		return this.each(function() {\n			var index,\n				hadTimers = false,\n				timers = jQuery.timers,\n				data = jQuery._data( this ),\n				// ++TRANSITION++\n				supportTransition = jQuery.support.transition;\n\n			// clear marker counters if we know they won't be\n			if ( !gotoEnd ) {\n				jQuery._unmark( true, this );\n			}\n\n			function stopQueue( elem, data, index ) {\n				var hooks = data[ index ];\n				jQuery.removeData( elem, index, true );\n				hooks.stop( gotoEnd );\n			}\n\n			if ( type == null ) {\n				for ( index in data ) {\n					if ( data[ index ] && data[ index ].stop && index.indexOf(\".run\") === index.length - 4 ) {\n						stopQueue( this, data, index );\n					}\n				}\n			} else if ( data[ index = type + \".run\" ] && data[ index ].stop ){\n				stopQueue( this, data, index );\n			}\n\n			for ( index = timers.length; index--; ) {\n				// ++TRANSITION++\n				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n					if ( gotoEnd || supportTransition ) {\n\n						// force the next step to be the last\n						timers[ index ]( /* ++TRANSITION++*/ gotoEnd );\n					}\n					if ( !gotoEnd ) {\n						timers[ index ].saveState();\n					}\n					hadTimers = true;\n					timers.splice( index, 1 );\n				}\n			}\n\n			// start the next in the queue if the last step wasn't forced\n			// timers currently will call their complete callbacks, which will dequeue\n			// but only if they were gotoEnd\n			if ( !( gotoEnd && hadTimers ) ) {\n				jQuery.dequeue( this, type );\n			}\n		});\n	}\n\n});\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n	setTimeout( clearFxNow, 0 );\n	return ( fxNow = jQuery.now() );\n}\n\nfunction clearFxNow() {\n	fxNow = undefined;\n}\n\n/*// Generate parameters to create a standard animation\nfunction genFx( type, num ) {\n	var obj = {};\n\n	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {\n		obj[ this ] = type;\n	});\n\n	return obj;\n}\n\n// Generate shortcuts for custom animations\njQuery.each({\n	slideDown: genFx( \"show\", 1 ),\n	slideUp: genFx( \"hide\", 1 ),\n	slideToggle: genFx( \"toggle\", 1 ),\n	fadeIn: { opacity: \"show\" },\n	fadeOut: { opacity: \"hide\" },\n	fadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n	jQuery.fn[ name ] = function( speed, easing, callback ) {\n		return this.animate( props, speed, easing, callback );\n	};\n});\n\njQuery.extend({\n	speed: function( speed, easing, fn ) {\n		var opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n			complete: fn || !fn && easing ||\n				jQuery.isFunction( speed ) && speed,\n			duration: speed,\n			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n		};\n\n		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n		// normalize opt.queue - true/undefined/null -> \"fx\"\n		if ( opt.queue == null || opt.queue === true ) {\n			opt.queue = \"fx\";\n		}\n\n		// Queueing\n		opt.old = opt.complete;\n\n		opt.complete = function( noUnmark ) {\n			if ( jQuery.isFunction( opt.old ) ) {\n				opt.old.call( this );\n			}\n\n			if ( opt.queue ) {\n				jQuery.dequeue( this, opt.queue );\n			} else if ( noUnmark !== false ) {\n				jQuery._unmark( this );\n			}\n		};\n\n		return opt;\n	},\n\n	easing: {\n		linear: function( p, n, firstNum, diff ) {\n			return firstNum + diff * p;\n		},\n		swing: function( p, n, firstNum, diff ) {\n			return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;\n		}\n	},\n\n	timers: [],\n\n	fx: function( elem, options, prop ) {\n		this.options = options;\n		this.elem = elem;\n		this.prop = prop;\n\n		options.orig = options.orig || {};\n	}\n\n});*/\n\njQuery.extend( jQuery.fx.prototype, {\n/*jQuery.fx.prototype = {\n	// Simple function for setting a style value\n	update: function() {\n		if ( this.options.step ) {\n			this.options.step.call( this.elem, this.now, this );\n		}\n\n		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );\n	},*/\n\n	// Get the current size\n	cur: function() {\n		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {\n			return this.elem[ this.prop ];\n		}\n\n		var parsed,\n			r = jQuery.css( this.elem, this.prop );\n		// Empty strings, null, undefined and \"auto\" are converted to 0,\n		// complex values such as \"rotate(1rad)\" are returned as is,\n		// simple values such as \"10px\" are parsed to Float.\n		return isNaN( parsed = parseFloat( r ) ) ? !r || r === \"auto\" ? 0 : r : parsed;\n	},\n\n	// Start an animation from one number to another\n	custom: function( from, to, unit ) {\n		var self = this,\n			fx = jQuery.fx,\n			// ++TRANSITION++\n			transition = self.options.transition,\n			// prop has to be saved, or it'll be undefined in the setTimeout closure\n			prop = this.prop;\n\n		this.startTime = fxNow || createFxNow();\n		this.end = to;\n		this.now = this.start = from;\n		this.pos = this.state = 0;\n		this.unit = unit || this.unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\n		function t( gotoEnd ) {\n			return self.step( gotoEnd );\n		}\n\n		t.queue = this.options.queue;\n		t.elem = this.elem;\n		t.saveState = function() {\n			if ( self.options.hide && jQuery._data( self.elem, \"fxshow\" + self.prop ) === undefined ) {\n				jQuery._data( self.elem, \"fxshow\" + self.prop, self.start );\n			}\n		};\n\n		// ++TRANSITION++\n		if ( ( t.transition = transition[ prop ] ) ) {\n			jQuery.timers.push( t );\n\n			// explicitly set the property to it's current computed value to workaround bugzil.la/571344\n			// transform shouldn't cause any problem in this case, as it is covered by the spec.\n			prop != \"transform\" && ( self.elem.style[ transition[ prop ].real ] = jQuery.css( self.elem, prop ) );\n\n			transition[ prop ].styleToSet = [ self.elem, prop, to + self.unit ];\n\n				// use a setTimeout to detect the end of a transition\n				// the transitionend event is unreliable\n				transition[ prop ].timeout = setTimeout(function() {\n					jQuery.timers.splice( jQuery.timers.indexOf( t ), 1 );\n					self.step( true );\n				// add an unperceptible delay to help some tests pass in Firefox\n				}, self.options.duration + 15);\n\n		} else if ( t() && jQuery.timers.push(t) && !timerId ) {\n			timerId = setInterval( fx.tick, fx.interval );\n		}\n	},\n\n	/*// Simple 'show' function\n	show: function() {\n		var dataShow = jQuery._data( this.elem, \"fxshow\" + this.prop );\n\n		// Remember where we started, so that we can go back to it later\n		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );\n		this.options.show = true;\n\n		// Begin the animation\n		// Make sure that we start at a small width/height to avoid any flash of content\n		if ( dataShow !== undefined ) {\n			// This show is picking up where a previous hide or show left off\n			this.custom( this.cur(), dataShow );\n		} else {\n			this.custom( this.prop === \"width\" || this.prop === \"height\" ? 1 : 0, this.cur() );\n		}\n\n		// Start by showing the element\n		jQuery( this.elem ).show();\n	},\n\n	// Simple 'hide' function\n	hide: function() {\n		// Remember where we started, so that we can go back to it later\n		this.options.orig[ this.prop ] = jQuery._data( this.elem, \"fxshow\" + this.prop ) || jQuery.style( this.elem, this.prop );\n		this.options.hide = true;\n\n		// Begin the animation\n		this.custom( this.cur(), 0 );\n	},*/\n\n	// Each step of an animation\n	step: function( gotoEnd ) {\n		var p, n, complete,\n			t = fxNow || createFxNow(),\n			done = true,\n			elem = this.elem,\n			options = this.options,\n			// ++TRANSITION++\n			transition = options.transition[ this.prop ],\n			supportTransition;\n\n		if ( transition || gotoEnd || t >= options.duration + this.startTime ) {\n			if ( !transition ) {\n				this.now = this.end;\n				this.pos = this.state = 1;\n				this.update();\n			// ++TRANSITION++\n			} else {\n				clearTimeout(transition.timeout);\n				// Stop a transition halfway through\n				if ( !gotoEnd ) {\n					// yes, stoping a transition halfway through should be as simple as setting a property to its current value.\n					// Try to call window.getComputedStyle() only once per element (in tick()?)\n					this.elem.style[transition.real] = jQuery.css( this.elem, transition.real );\n				}\n			}\n\n			options.animatedProperties[ this.prop ] = true;\n\n			for ( p in options.animatedProperties ) {\n				if ( options.animatedProperties[ p ] !== true ) {\n					done = false;\n				}\n			}\n\n			if ( done ) {\n				// Reset the overflow\n				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {\n\n					jQuery.each( [ \"\", \"X\", \"Y\" ], function( index, value ) {\n						elem.style[ \"overflow\" + value ] = options.overflow[ index ];\n					});\n				}\n\n				// Hide the element if the \"hide\" operation was done\n				if ( options.hide ) {\n					jQuery( elem ).hide();\n				}\n\n				// Reset the properties, if the item has been hidden or shown\n				if ( options.hide || options.show ) {\n					for ( p in options.animatedProperties ) {\n						jQuery.style( elem, p, options.orig[ p ] );\n						jQuery.removeData( elem, \"fxshow\" + p, true );\n						// Toggle data is no longer needed\n						jQuery.removeData( elem, \"toggle\" + p, true );\n					}\n				}\n\n				// ++TRANSITION++\n				// cleanup the transition property\n				if ( (supportTransition = elem.nodeType === 1 && jQuery.support.transition) ) {\n					transition = ',' + elem.style[supportTransition];\n					for ( p in options.transition ) {\n						transition = transition.split( options.transition[p].lower ).join('_');\n					}\n					elem.style[supportTransition] = transition.replace(/, ?_[^,]*/g, '').substr(1);\n				}\n\n				// Execute the complete function\n				// in the event that the complete function throws an exception\n				// we must ensure it won't be called twice. #5684\n\n				complete = options.complete;\n				if ( complete ) {\n\n					options.complete = false;\n					complete.call( elem );\n				}\n			}\n\n			return false;\n\n		} else {\n			// classical easing cannot be used with an Infinity duration\n			if ( options.duration == Infinity ) {\n				this.now = t;\n			} else {\n				n = t - this.startTime;\n				this.state = n / options.duration;\n\n				// Perform the easing function, defaults to swing\n				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );\n				this.now = this.start + ( (this.end - this.start) * this.pos );\n			}\n			// Perform the next step of the animation\n			this.update();\n		}\n\n		return true;\n	}\n});//};\n\njQuery.extend( jQuery.fx, {\n	tick: function() {\n		var timer,\n			timers = jQuery.timers,\n			i = 0;\n\n		for ( ; i < timers.length; i++ ) {\n			timer = timers[ i ];\n			// Checks the timer has not already been removed\n			// ++TRANSITION++\n			if ( !timer.transition && !timer() && timers[ i ] === timer ) {\n				timers.splice( i--, 1 );\n			}\n		}\n\n		if ( !timers.length ) {\n			jQuery.fx.stop();\n		}\n	}/*,\n\n	interval: 13,\n\n	stop: function() {\n		clearInterval( timerId );\n		timerId = null;\n	},\n\n	speeds: {\n		slow: 600,\n		fast: 200,\n		// Default speed\n		_default: 400\n	},\n\n	step: {\n		opacity: function( fx ) {\n			jQuery.style( fx.elem, \"opacity\", fx.now );\n		},\n\n		_default: function( fx ) {\n			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {\n				fx.elem.style[ fx.prop ] = fx.now + fx.unit;\n			} else {\n				fx.elem[ fx.prop ] = fx.now;\n			}\n		}\n	}*/\n});\n\n/*// Adds width/height step functions\n// Do not set anything below 0\njQuery.each([ \"width\", \"height\" ], function( i, prop ) {\n	jQuery.fx.step[ prop ] = function( fx ) {\n		jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );\n	};\n});\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n	jQuery.expr.filters.animated = function( elem ) {\n		return jQuery.grep(jQuery.timers, function( fn ) {\n			return elem === fn.elem;\n		}).length;\n	};\n}*/\n\n// Try to restore the default display value of an element\nfunction defaultDisplay( nodeName ) {\n\n	if ( !elemdisplay[ nodeName ] ) {\n\n		var body = document.body,\n			elem = jQuery( \"<\" + nodeName + \">\" ).appendTo( body ),\n			display = elem.css( \"display\" );\n		elem.remove();\n\n		// If the simple way fails,\n		// get element's real default display by attaching it to a temp iframe\n		if ( display === \"none\" || display === \"\" ) {\n			// No iframe to use yet, so create it\n			if ( !iframe ) {\n				iframe = document.createElement( \"iframe\" );\n				iframe.frameBorder = iframe.width = iframe.height = 0;\n			}\n\n			body.appendChild( iframe );\n\n			// Create a cacheable copy of the iframe document on first call.\n			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML\n			// document to it; WebKit & Firefox won't allow reusing the iframe document.\n			if ( !iframeDoc || !iframe.createElement ) {\n				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;\n				iframeDoc.write( ( document.compatMode === \"CSS1Compat\" ? \"<!doctype html>\" : \"\" ) + \"<html><body>\" );\n				iframeDoc.close();\n			}\n\n			elem = iframeDoc.createElement( nodeName );\n\n			iframeDoc.body.appendChild( elem );\n\n			display = jQuery.css( elem, \"display\" );\n			body.removeChild( iframe );\n		}\n\n		// Store the correct default display\n		elemdisplay[ nodeName ] = display;\n	}\n\n	return elemdisplay[ nodeName ];\n}\n\n})( jQuery );\n//@ sourceURL=vendor/jquery-transition.js\n});");

// module: vendor/knockout-debug
// file:   vendor/knockout-debug.js
eval("define(\"vendor/knockout-debug\", function(require, exports, module) { // Knockout JavaScript library v2.1.0\n// (c) Steven Sanderson - http://knockoutjs.com/\n// License: MIT (http://www.opensource.org/licenses/mit-license.php)\n\n(function(window,document,navigator,undefined){\nvar DEBUG=true;\n!function(factory) {\n    // Support three module loading scenarios\n    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {\n        // [1] CommonJS/Node.js\n        var target = module['exports'] || exports; // module.exports is for Node.js\n        factory(target);\n    } else if (typeof define === 'function' && define['amd']) {\n        // [2] AMD anonymous module\n        define(['exports'], factory);\n    } else {\n        // [3] No module loader (plain <script> tag) - put directly in global namespace\n        factory(window['ko'] = {});\n    }\n}(function(koExports){\n// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).\n// In the future, the following \"ko\" variable may be made distinct from \"koExports\" so that private objects are not externally reachable.\nvar ko = typeof koExports !== 'undefined' ? koExports : {};\n// Google Closure Compiler helpers (used only to make the minified file smaller)\nko.exportSymbol = function(koPath, object) {\n    var tokens = koPath.split(\".\");\n\n    // In the future, \"ko\" may become distinct from \"koExports\" (so that non-exported objects are not reachable)\n    // At that point, \"target\" would be set to: (typeof koExports !== \"undefined\" ? koExports : ko)\n    var target = ko;\n\n    for (var i = 0; i < tokens.length - 1; i++)\n        target = target[tokens[i]];\n    target[tokens[tokens.length - 1]] = object;\n};\nko.exportProperty = function(owner, publicName, object) {\n  owner[publicName] = object;\n};\nko.version = \"2.1.0\";\n\nko.exportSymbol('version', ko.version);\nko.utils = new (function () {\n    var stringTrimRegex = /^(\\s|\\u00A0)+|(\\s|\\u00A0)+$/g;\n\n    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)\n    var knownEvents = {}, knownEventTypesByEventName = {};\n    var keyEventTypeName = /Firefox\\/2/i.test(navigator.userAgent) ? 'KeyboardEvent' : 'UIEvents';\n    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];\n    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];\n    for (var eventType in knownEvents) {\n        var knownEventsForType = knownEvents[eventType];\n        if (knownEventsForType.length) {\n            for (var i = 0, j = knownEventsForType.length; i < j; i++)\n                knownEventTypesByEventName[knownEventsForType[i]] = eventType;\n        }\n    }\n    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406\n\n    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)\n    var ieVersion = (function() {\n        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');\n\n        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment\n        while (\n            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',\n            iElems[0]\n        );\n        return version > 4 ? version : undefined;\n    }());\n    var isIe6 = ieVersion === 6,\n        isIe7 = ieVersion === 7;\n\n    function isClickOnCheckableElement(element, eventType) {\n        if ((ko.utils.tagNameLower(element) !== \"input\") || !element.type) return false;\n        if (eventType.toLowerCase() != \"click\") return false;\n        var inputType = element.type;\n        return (inputType == \"checkbox\") || (inputType == \"radio\");\n    }\n\n    return {\n        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],\n\n        arrayForEach: function (array, action) {\n            for (var i = 0, j = array.length; i < j; i++)\n                action(array[i]);\n        },\n\n        arrayIndexOf: function (array, item) {\n            if (typeof Array.prototype.indexOf == \"function\")\n                return Array.prototype.indexOf.call(array, item);\n            for (var i = 0, j = array.length; i < j; i++)\n                if (array[i] === item)\n                    return i;\n            return -1;\n        },\n\n        arrayFirst: function (array, predicate, predicateOwner) {\n            for (var i = 0, j = array.length; i < j; i++)\n                if (predicate.call(predicateOwner, array[i]))\n                    return array[i];\n            return null;\n        },\n\n        arrayRemoveItem: function (array, itemToRemove) {\n            var index = ko.utils.arrayIndexOf(array, itemToRemove);\n            if (index >= 0)\n                array.splice(index, 1);\n        },\n\n        arrayGetDistinctValues: function (array) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++) {\n                if (ko.utils.arrayIndexOf(result, array[i]) < 0)\n                    result.push(array[i]);\n            }\n            return result;\n        },\n\n        arrayMap: function (array, mapping) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++)\n                result.push(mapping(array[i]));\n            return result;\n        },\n\n        arrayFilter: function (array, predicate) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++)\n                if (predicate(array[i]))\n                    result.push(array[i]);\n            return result;\n        },\n\n        arrayPushAll: function (array, valuesToPush) {\n            if (valuesToPush instanceof Array)\n                array.push.apply(array, valuesToPush);\n            else\n                for (var i = 0, j = valuesToPush.length; i < j; i++)\n                    array.push(valuesToPush[i]);\n            return array;\n        },\n\n        extend: function (target, source) {\n            if (source) {\n                for(var prop in source) {\n                    if(source.hasOwnProperty(prop)) {\n                        target[prop] = source[prop];\n                    }\n                }\n            }\n            return target;\n        },\n\n        emptyDomNode: function (domNode) {\n            while (domNode.firstChild) {\n                ko.removeNode(domNode.firstChild);\n            }\n        },\n\n        moveCleanedNodesToContainerElement: function(nodes) {\n            // Ensure it's a real array, as we're about to reparent the nodes and\n            // we don't want the underlying collection to change while we're doing that.\n            var nodesArray = ko.utils.makeArray(nodes);\n\n            var container = document.createElement('div');\n            for (var i = 0, j = nodesArray.length; i < j; i++) {\n                ko.cleanNode(nodesArray[i]);\n                container.appendChild(nodesArray[i]);\n            }\n            return container;\n        },\n\n        setDomNodeChildren: function (domNode, childNodes) {\n            ko.utils.emptyDomNode(domNode);\n            if (childNodes) {\n                for (var i = 0, j = childNodes.length; i < j; i++)\n                    domNode.appendChild(childNodes[i]);\n            }\n        },\n\n        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {\n            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;\n            if (nodesToReplaceArray.length > 0) {\n                var insertionPoint = nodesToReplaceArray[0];\n                var parent = insertionPoint.parentNode;\n                for (var i = 0, j = newNodesArray.length; i < j; i++)\n                    parent.insertBefore(newNodesArray[i], insertionPoint);\n                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {\n                    ko.removeNode(nodesToReplaceArray[i]);\n                }\n            }\n        },\n\n        setOptionNodeSelectionState: function (optionNode, isSelected) {\n            // IE6 sometimes throws \"unknown error\" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.\n            if (navigator.userAgent.indexOf(\"MSIE 6\") >= 0)\n                optionNode.setAttribute(\"selected\", isSelected);\n            else\n                optionNode.selected = isSelected;\n        },\n\n        stringTrim: function (string) {\n            return (string || \"\").replace(stringTrimRegex, \"\");\n        },\n\n        stringTokenize: function (string, delimiter) {\n            var result = [];\n            var tokens = (string || \"\").split(delimiter);\n            for (var i = 0, j = tokens.length; i < j; i++) {\n                var trimmed = ko.utils.stringTrim(tokens[i]);\n                if (trimmed !== \"\")\n                    result.push(trimmed);\n            }\n            return result;\n        },\n\n        stringStartsWith: function (string, startsWith) {\n            string = string || \"\";\n            if (startsWith.length > string.length)\n                return false;\n            return string.substring(0, startsWith.length) === startsWith;\n        },\n\n        buildEvalWithinScopeFunction: function (expression, scopeLevels) {\n            // Build the source for a function that evaluates \"expression\"\n            // For each scope variable, add an extra level of \"with\" nesting\n            // Example result: with(sc[1]) { with(sc[0]) { return (expression) } }\n            var functionBody = \"return (\" + expression + \")\";\n            for (var i = 0; i < scopeLevels; i++) {\n                functionBody = \"with(sc[\" + i + \"]) { \" + functionBody + \" } \";\n            }\n            return new Function(\"sc\", functionBody);\n        },\n\n        domNodeIsContainedBy: function (node, containedByNode) {\n            if (containedByNode.compareDocumentPosition)\n                return (containedByNode.compareDocumentPosition(node) & 16) == 16;\n            while (node != null) {\n                if (node == containedByNode)\n                    return true;\n                node = node.parentNode;\n            }\n            return false;\n        },\n\n        domNodeIsAttachedToDocument: function (node) {\n            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument);\n        },\n\n        tagNameLower: function(element) {\n            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.\n            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),\n            // we don't need to do the .toLowerCase() as it will always be lower case anyway.\n            return element && element.tagName && element.tagName.toLowerCase();\n        },\n\n        registerEventHandler: function (element, eventType, handler) {\n            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];\n            if (!mustUseAttachEvent && typeof jQuery != \"undefined\") {\n                if (isClickOnCheckableElement(element, eventType)) {\n                    // For click events on checkboxes, jQuery interferes with the event handling in an awkward way:\n                    // it toggles the element checked state *after* the click event handlers run, whereas native\n                    // click events toggle the checked state *before* the event handler.\n                    // Fix this by intecepting the handler and applying the correct checkedness before it runs.\n                    var originalHandler = handler;\n                    handler = function(event, eventData) {\n                        var jQuerySuppliedCheckedState = this.checked;\n                        if (eventData)\n                            this.checked = eventData.checkedStateBeforeEvent !== true;\n                        originalHandler.call(this, event);\n                        this.checked = jQuerySuppliedCheckedState; // Restore the state jQuery applied\n                    };\n                }\n                jQuery(element)['bind'](eventType, handler);\n            } else if (!mustUseAttachEvent && typeof element.addEventListener == \"function\")\n                element.addEventListener(eventType, handler, false);\n            else if (typeof element.attachEvent != \"undefined\")\n                element.attachEvent(\"on\" + eventType, function (event) {\n                    handler.call(element, event);\n                });\n            else\n                throw new Error(\"Browser doesn't support addEventListener or attachEvent\");\n        },\n\n        triggerEvent: function (element, eventType) {\n            if (!(element && element.nodeType))\n                throw new Error(\"element must be a DOM node when calling triggerEvent\");\n\n            if (typeof jQuery != \"undefined\") {\n                var eventData = [];\n                if (isClickOnCheckableElement(element, eventType)) {\n                    // Work around the jQuery \"click events on checkboxes\" issue described above by storing the original checked state before triggering the handler\n                    eventData.push({ checkedStateBeforeEvent: element.checked });\n                }\n                jQuery(element)['trigger'](eventType, eventData);\n            } else if (typeof document.createEvent == \"function\") {\n                if (typeof element.dispatchEvent == \"function\") {\n                    var eventCategory = knownEventTypesByEventName[eventType] || \"HTMLEvents\";\n                    var event = document.createEvent(eventCategory);\n                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);\n                    element.dispatchEvent(event);\n                }\n                else\n                    throw new Error(\"The supplied element doesn't support dispatchEvent\");\n            } else if (typeof element.fireEvent != \"undefined\") {\n                // Unlike other browsers, IE doesn't change the checked state of checkboxes/radiobuttons when you trigger their \"click\" event\n                // so to make it consistent, we'll do it manually here\n                if (isClickOnCheckableElement(element, eventType))\n                    element.checked = element.checked !== true;\n                element.fireEvent(\"on\" + eventType);\n            }\n            else\n                throw new Error(\"Browser doesn't support triggering events\");\n        },\n\n        unwrapObservable: function (value) {\n            return ko.isObservable(value) ? value() : value;\n        },\n\n        toggleDomNodeCssClass: function (node, className, shouldHaveClass) {\n            var currentClassNames = (node.className || \"\").split(/\\s+/);\n            var hasClass = ko.utils.arrayIndexOf(currentClassNames, className) >= 0;\n\n            if (shouldHaveClass && !hasClass) {\n                node.className += (currentClassNames[0] ? \" \" : \"\") + className;\n            } else if (hasClass && !shouldHaveClass) {\n                var newClassName = \"\";\n                for (var i = 0; i < currentClassNames.length; i++)\n                    if (currentClassNames[i] != className)\n                        newClassName += currentClassNames[i] + \" \";\n                node.className = ko.utils.stringTrim(newClassName);\n            }\n        },\n\n        setTextContent: function(element, textContent) {\n            var value = ko.utils.unwrapObservable(textContent);\n            if ((value === null) || (value === undefined))\n                value = \"\";\n\n            'innerText' in element ? element.innerText = value\n                                   : element.textContent = value;\n\n            if (ieVersion >= 9) {\n                // Believe it or not, this actually fixes an IE9 rendering bug\n                // (See https://github.com/SteveSanderson/knockout/issues/209)\n                element.style.display = element.style.display;\n            }\n        },\n\n        ensureSelectElementIsRenderedCorrectly: function(selectElement) {\n            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.\n            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)\n            if (ieVersion >= 9) {\n                var originalWidth = selectElement.style.width;\n                selectElement.style.width = 0;\n                selectElement.style.width = originalWidth;\n            }\n        },\n\n        range: function (min, max) {\n            min = ko.utils.unwrapObservable(min);\n            max = ko.utils.unwrapObservable(max);\n            var result = [];\n            for (var i = min; i <= max; i++)\n                result.push(i);\n            return result;\n        },\n\n        makeArray: function(arrayLikeObject) {\n            var result = [];\n            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {\n                result.push(arrayLikeObject[i]);\n            };\n            return result;\n        },\n\n        isIe6 : isIe6,\n        isIe7 : isIe7,\n        ieVersion : ieVersion,\n\n        getFormFields: function(form, fieldName) {\n            var fields = ko.utils.makeArray(form.getElementsByTagName(\"input\")).concat(ko.utils.makeArray(form.getElementsByTagName(\"textarea\")));\n            var isMatchingField = (typeof fieldName == 'string')\n                ? function(field) { return field.name === fieldName }\n                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate\n            var matches = [];\n            for (var i = fields.length - 1; i >= 0; i--) {\n                if (isMatchingField(fields[i]))\n                    matches.push(fields[i]);\n            };\n            return matches;\n        },\n\n        parseJson: function (jsonString) {\n            if (typeof jsonString == \"string\") {\n                jsonString = ko.utils.stringTrim(jsonString);\n                if (jsonString) {\n                    if (window.JSON && window.JSON.parse) // Use native parsing where available\n                        return window.JSON.parse(jsonString);\n                    return (new Function(\"return \" + jsonString))(); // Fallback on less safe parsing for older browsers\n                }\n            }\n            return null;\n        },\n\n        stringifyJson: function (data, replacer, space) {   // replacer and space are optional\n            if ((typeof JSON == \"undefined\") || (typeof JSON.stringify == \"undefined\"))\n                throw new Error(\"Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js\");\n            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);\n        },\n\n        postJson: function (urlOrForm, data, options) {\n            options = options || {};\n            var params = options['params'] || {};\n            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;\n            var url = urlOrForm;\n\n            // If we were given a form, use its 'action' URL and pick out any requested field values\n            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === \"form\")) {\n                var originalForm = urlOrForm;\n                url = originalForm.action;\n                for (var i = includeFields.length - 1; i >= 0; i--) {\n                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);\n                    for (var j = fields.length - 1; j >= 0; j--)\n                        params[fields[j].name] = fields[j].value;\n                }\n            }\n\n            data = ko.utils.unwrapObservable(data);\n            var form = document.createElement(\"form\");\n            form.style.display = \"none\";\n            form.action = url;\n            form.method = \"post\";\n            for (var key in data) {\n                var input = document.createElement(\"input\");\n                input.name = key;\n                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));\n                form.appendChild(input);\n            }\n            for (var key in params) {\n                var input = document.createElement(\"input\");\n                input.name = key;\n                input.value = params[key];\n                form.appendChild(input);\n            }\n            document.body.appendChild(form);\n            options['submitter'] ? options['submitter'](form) : form.submit();\n            setTimeout(function () { form.parentNode.removeChild(form); }, 0);\n        }\n    }\n})();\n\nko.exportSymbol('utils', ko.utils);\nko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);\nko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);\nko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);\nko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);\nko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);\nko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);\nko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);\nko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);\nko.exportSymbol('utils.extend', ko.utils.extend);\nko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);\nko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);\nko.exportSymbol('utils.postJson', ko.utils.postJson);\nko.exportSymbol('utils.parseJson', ko.utils.parseJson);\nko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);\nko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);\nko.exportSymbol('utils.range', ko.utils.range);\nko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);\nko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);\nko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);\n\nif (!Function.prototype['bind']) {\n    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)\n    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js\n    Function.prototype['bind'] = function (object) {\n        var originalFunction = this, args = Array.prototype.slice.call(arguments), object = args.shift();\n        return function () {\n            return originalFunction.apply(object, args.concat(Array.prototype.slice.call(arguments)));\n        };\n    };\n}\n\nko.utils.domData = new (function () {\n    var uniqueId = 0;\n    var dataStoreKeyExpandoPropertyName = \"__ko__\" + (new Date).getTime();\n    var dataStore = {};\n    return {\n        get: function (node, key) {\n            var allDataForNode = ko.utils.domData.getAll(node, false);\n            return allDataForNode === undefined ? undefined : allDataForNode[key];\n        },\n        set: function (node, key, value) {\n            if (value === undefined) {\n                // Make sure we don't actually create a new domData key if we are actually deleting a value\n                if (ko.utils.domData.getAll(node, false) === undefined)\n                    return;\n            }\n            var allDataForNode = ko.utils.domData.getAll(node, true);\n            allDataForNode[key] = value;\n        },\n        getAll: function (node, createIfNotFound) {\n            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];\n            var hasExistingDataStore = dataStoreKey && (dataStoreKey !== \"null\");\n            if (!hasExistingDataStore) {\n                if (!createIfNotFound)\n                    return undefined;\n                dataStoreKey = node[dataStoreKeyExpandoPropertyName] = \"ko\" + uniqueId++;\n                dataStore[dataStoreKey] = {};\n            }\n            return dataStore[dataStoreKey];\n        },\n        clear: function (node) {\n            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];\n            if (dataStoreKey) {\n                delete dataStore[dataStoreKey];\n                node[dataStoreKeyExpandoPropertyName] = null;\n            }\n        }\n    }\n})();\n\nko.exportSymbol('utils.domData', ko.utils.domData);\nko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully\n\nko.utils.domNodeDisposal = new (function () {\n    var domDataKey = \"__ko_domNodeDisposal__\" + (new Date).getTime();\n    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document\n    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document\n\n    function getDisposeCallbacksCollection(node, createIfNotFound) {\n        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);\n        if ((allDisposeCallbacks === undefined) && createIfNotFound) {\n            allDisposeCallbacks = [];\n            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);\n        }\n        return allDisposeCallbacks;\n    }\n    function destroyCallbacksCollection(node) {\n        ko.utils.domData.set(node, domDataKey, undefined);\n    }\n\n    function cleanSingleNode(node) {\n        // Run all the dispose callbacks\n        var callbacks = getDisposeCallbacksCollection(node, false);\n        if (callbacks) {\n            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)\n            for (var i = 0; i < callbacks.length; i++)\n                callbacks[i](node);\n        }\n\n        // Also erase the DOM data\n        ko.utils.domData.clear(node);\n\n        // Special support for jQuery here because it's so commonly used.\n        // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData\n        // so notify it to tear down any resources associated with the node & descendants here.\n        if ((typeof jQuery == \"function\") && (typeof jQuery['cleanData'] == \"function\"))\n            jQuery['cleanData']([node]);\n\n        // Also clear any immediate-child comment nodes, as these wouldn't have been found by\n        // node.getElementsByTagName(\"*\") in cleanNode() (comment nodes aren't elements)\n        if (cleanableNodeTypesWithDescendants[node.nodeType])\n            cleanImmediateCommentTypeChildren(node);\n    }\n\n    function cleanImmediateCommentTypeChildren(nodeWithChildren) {\n        var child, nextChild = nodeWithChildren.firstChild;\n        while (child = nextChild) {\n            nextChild = child.nextSibling;\n            if (child.nodeType === 8)\n                cleanSingleNode(child);\n        }\n    }\n\n    return {\n        addDisposeCallback : function(node, callback) {\n            if (typeof callback != \"function\")\n                throw new Error(\"Callback must be a function\");\n            getDisposeCallbacksCollection(node, true).push(callback);\n        },\n\n        removeDisposeCallback : function(node, callback) {\n            var callbacksCollection = getDisposeCallbacksCollection(node, false);\n            if (callbacksCollection) {\n                ko.utils.arrayRemoveItem(callbacksCollection, callback);\n                if (callbacksCollection.length == 0)\n                    destroyCallbacksCollection(node);\n            }\n        },\n\n        cleanNode : function(node) {\n            // First clean this node, where applicable\n            if (cleanableNodeTypes[node.nodeType]) {\n                cleanSingleNode(node);\n\n                // ... then its descendants, where applicable\n                if (cleanableNodeTypesWithDescendants[node.nodeType]) {\n                    // Clone the descendants list in case it changes during iteration\n                    var descendants = [];\n                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName(\"*\"));\n                    for (var i = 0, j = descendants.length; i < j; i++)\n                        cleanSingleNode(descendants[i]);\n                }\n            }\n        },\n\n        removeNode : function(node) {\n            ko.cleanNode(node);\n            if (node.parentNode)\n                node.parentNode.removeChild(node);\n        }\n    }\n})();\nko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience\nko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience\nko.exportSymbol('cleanNode', ko.cleanNode);\nko.exportSymbol('removeNode', ko.removeNode);\nko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);\nko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);\nko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);\n(function () {\n    var leadingCommentRegex = /^(\\s*)<!--(.*?)-->/;\n\n    function simpleHtmlParse(html) {\n        // Based on jQuery's \"clean\" function, but only accounting for table-related elements.\n        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's \"clean\" function directly\n\n        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of\n        // a descendant node. For example: \"<div><!-- mycomment -->abc</div>\" will get parsed as \"<div>abc</div>\"\n        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node\n        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.\n\n        // Trim whitespace, otherwise indexOf won't work as expected\n        var tags = ko.utils.stringTrim(html).toLowerCase(), div = document.createElement(\"div\");\n\n        // Finds the first match from the left column, and returns the corresponding \"wrap\" data from the right column\n        var wrap = tags.match(/^<(thead|tbody|tfoot)/)              && [1, \"<table>\", \"</table>\"] ||\n                   !tags.indexOf(\"<tr\")                             && [2, \"<table><tbody>\", \"</tbody></table>\"] ||\n                   (!tags.indexOf(\"<td\") || !tags.indexOf(\"<th\"))   && [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"] ||\n                   /* anything else */                                 [0, \"\", \"\"];\n\n        // Go to html and back, then peel off extra wrappers\n        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.\n        var markup = \"ignored<div>\" + wrap[1] + html + wrap[2] + \"</div>\";\n        if (typeof window['innerShiv'] == \"function\") {\n            div.appendChild(window['innerShiv'](markup));\n        } else {\n            div.innerHTML = markup;\n        }\n\n        // Move to the right depth\n        while (wrap[0]--)\n            div = div.lastChild;\n\n        return ko.utils.makeArray(div.lastChild.childNodes);\n    }\n\n    function jQueryHtmlParse(html) {\n        var elems = jQuery['clean']([html]);\n\n        // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.\n        // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.\n        // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.\n        if (elems && elems[0]) {\n            // Find the top-most parent element that's a direct child of a document fragment\n            var elem = elems[0];\n            while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)\n                elem = elem.parentNode;\n            // ... then detach it\n            if (elem.parentNode)\n                elem.parentNode.removeChild(elem);\n        }\n\n        return elems;\n    }\n\n    ko.utils.parseHtmlFragment = function(html) {\n        return typeof jQuery != 'undefined' ? jQueryHtmlParse(html)   // As below, benefit from jQuery's optimisations where possible\n                                            : simpleHtmlParse(html);  // ... otherwise, this simple logic will do in most common cases.\n    };\n\n    ko.utils.setHtml = function(node, html) {\n        ko.utils.emptyDomNode(node);\n\n        if ((html !== null) && (html !== undefined)) {\n            if (typeof html != 'string')\n                html = html.toString();\n\n            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,\n            // for example <tr> elements which are not normally allowed to exist on their own.\n            // If you've referenced jQuery we'll use that rather than duplicating its code.\n            if (typeof jQuery != 'undefined') {\n                jQuery(node)['html'](html);\n            } else {\n                // ... otherwise, use KO's own parsing logic.\n                var parsedNodes = ko.utils.parseHtmlFragment(html);\n                for (var i = 0; i < parsedNodes.length; i++)\n                    node.appendChild(parsedNodes[i]);\n            }\n        }\n    };\n})();\n\nko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);\nko.exportSymbol('utils.setHtml', ko.utils.setHtml);\n\nko.memoization = (function () {\n    var memos = {};\n\n    function randomMax8HexChars() {\n        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);\n    }\n    function generateRandomId() {\n        return randomMax8HexChars() + randomMax8HexChars();\n    }\n    function findMemoNodes(rootNode, appendToArray) {\n        if (!rootNode)\n            return;\n        if (rootNode.nodeType == 8) {\n            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);\n            if (memoId != null)\n                appendToArray.push({ domNode: rootNode, memoId: memoId });\n        } else if (rootNode.nodeType == 1) {\n            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)\n                findMemoNodes(childNodes[i], appendToArray);\n        }\n    }\n\n    return {\n        memoize: function (callback) {\n            if (typeof callback != \"function\")\n                throw new Error(\"You can only pass a function to ko.memoization.memoize()\");\n            var memoId = generateRandomId();\n            memos[memoId] = callback;\n            return \"<!--[ko_memo:\" + memoId + \"]-->\";\n        },\n\n        unmemoize: function (memoId, callbackParams) {\n            var callback = memos[memoId];\n            if (callback === undefined)\n                throw new Error(\"Couldn't find any memo with ID \" + memoId + \". Perhaps it's already been unmemoized.\");\n            try {\n                callback.apply(null, callbackParams || []);\n                return true;\n            }\n            finally { delete memos[memoId]; }\n        },\n\n        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {\n            var memos = [];\n            findMemoNodes(domNode, memos);\n            for (var i = 0, j = memos.length; i < j; i++) {\n                var node = memos[i].domNode;\n                var combinedParams = [node];\n                if (extraCallbackParamsArray)\n                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);\n                ko.memoization.unmemoize(memos[i].memoId, combinedParams);\n                node.nodeValue = \"\"; // Neuter this node so we don't try to unmemoize it again\n                if (node.parentNode)\n                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)\n            }\n        },\n\n        parseMemoText: function (memoText) {\n            var match = memoText.match(/^\\[ko_memo\\:(.*?)\\]$/);\n            return match ? match[1] : null;\n        }\n    };\n})();\n\nko.exportSymbol('memoization', ko.memoization);\nko.exportSymbol('memoization.memoize', ko.memoization.memoize);\nko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);\nko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);\nko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);\nko.extenders = {\n    'throttle': function(target, timeout) {\n        // Throttling means two things:\n\n        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies\n        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate\n        target['throttleEvaluation'] = timeout;\n\n        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*\n        //     so the target cannot change value synchronously or faster than a certain rate\n        var writeTimeoutInstance = null;\n        return ko.dependentObservable({\n            'read': target,\n            'write': function(value) {\n                clearTimeout(writeTimeoutInstance);\n                writeTimeoutInstance = setTimeout(function() {\n                    target(value);\n                }, timeout);\n            }\n        });\n    },\n\n    'notify': function(target, notifyWhen) {\n        target[\"equalityComparer\"] = notifyWhen == \"always\"\n            ? function() { return false } // Treat all values as not equal\n            : ko.observable[\"fn\"][\"equalityComparer\"];\n        return target;\n    }\n};\n\nfunction applyExtenders(requestedExtenders) {\n    var target = this;\n    if (requestedExtenders) {\n        for (var key in requestedExtenders) {\n            var extenderHandler = ko.extenders[key];\n            if (typeof extenderHandler == 'function') {\n                target = extenderHandler(target, requestedExtenders[key]);\n            }\n        }\n    }\n    return target;\n}\n\nko.exportSymbol('extenders', ko.extenders);\n\nko.subscription = function (target, callback, disposeCallback) {\n    this.target = target;\n    this.callback = callback;\n    this.disposeCallback = disposeCallback;\n    ko.exportProperty(this, 'dispose', this.dispose);\n};\nko.subscription.prototype.dispose = function () {\n    this.isDisposed = true;\n    this.disposeCallback();\n};\n\nko.subscribable = function () {\n    this._subscriptions = {};\n\n    ko.utils.extend(this, ko.subscribable['fn']);\n    ko.exportProperty(this, 'subscribe', this.subscribe);\n    ko.exportProperty(this, 'extend', this.extend);\n    ko.exportProperty(this, 'getSubscriptionsCount', this.getSubscriptionsCount);\n}\n\nvar defaultEvent = \"change\";\n\nko.subscribable['fn'] = {\n    subscribe: function (callback, callbackTarget, event) {\n        event = event || defaultEvent;\n        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;\n\n        var subscription = new ko.subscription(this, boundCallback, function () {\n            ko.utils.arrayRemoveItem(this._subscriptions[event], subscription);\n        }.bind(this));\n\n        if (!this._subscriptions[event])\n            this._subscriptions[event] = [];\n        this._subscriptions[event].push(subscription);\n        return subscription;\n    },\n\n    \"notifySubscribers\": function (valueToNotify, event) {\n        event = event || defaultEvent;\n        if (this._subscriptions[event]) {\n            ko.utils.arrayForEach(this._subscriptions[event].slice(0), function (subscription) {\n                // In case a subscription was disposed during the arrayForEach cycle, check\n                // for isDisposed on each subscription before invoking its callback\n                if (subscription && (subscription.isDisposed !== true))\n                    subscription.callback(valueToNotify);\n            });\n        }\n    },\n\n    getSubscriptionsCount: function () {\n        var total = 0;\n        for (var eventName in this._subscriptions) {\n            if (this._subscriptions.hasOwnProperty(eventName))\n                total += this._subscriptions[eventName].length;\n        }\n        return total;\n    },\n\n    extend: applyExtenders\n};\n\n\nko.isSubscribable = function (instance) {\n    return typeof instance.subscribe == \"function\" && typeof instance[\"notifySubscribers\"] == \"function\";\n};\n\nko.exportSymbol('subscribable', ko.subscribable);\nko.exportSymbol('isSubscribable', ko.isSubscribable);\n\nko.dependencyDetection = (function () {\n    var _frames = [];\n\n    return {\n        begin: function (callback) {\n            _frames.push({ callback: callback, distinctDependencies:[] });\n        },\n\n        end: function () {\n            _frames.pop();\n        },\n\n        registerDependency: function (subscribable) {\n            if (!ko.isSubscribable(subscribable))\n                throw new Error(\"Only subscribable things can act as dependencies\");\n            if (_frames.length > 0) {\n                var topFrame = _frames[_frames.length - 1];\n                if (ko.utils.arrayIndexOf(topFrame.distinctDependencies, subscribable) >= 0)\n                    return;\n                topFrame.distinctDependencies.push(subscribable);\n                topFrame.callback(subscribable);\n            }\n        }\n    };\n})();\nvar primitiveTypes = { 'undefined':true, 'boolean':true, 'number':true, 'string':true };\n\nko.observable = function (initialValue) {\n    var _latestValue = initialValue;\n\n    function observable() {\n        if (arguments.length > 0) {\n            // Write\n\n            // Ignore writes if the value hasn't changed\n            if ((!observable['equalityComparer']) || !observable['equalityComparer'](_latestValue, arguments[0])) {\n                observable.valueWillMutate();\n                _latestValue = arguments[0];\n                if (DEBUG) observable._latestValue = _latestValue;\n                observable.valueHasMutated();\n            }\n            return this; // Permits chained assignments\n        }\n        else {\n            // Read\n            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a \"read\" operation\n            return _latestValue;\n        }\n    }\n    if (DEBUG) observable._latestValue = _latestValue;\n    ko.subscribable.call(observable);\n    observable.valueHasMutated = function () { observable[\"notifySubscribers\"](_latestValue); }\n    observable.valueWillMutate = function () { observable[\"notifySubscribers\"](_latestValue, \"beforeChange\"); }\n    ko.utils.extend(observable, ko.observable['fn']);\n\n    ko.exportProperty(observable, \"valueHasMutated\", observable.valueHasMutated);\n    ko.exportProperty(observable, \"valueWillMutate\", observable.valueWillMutate);\n\n    return observable;\n}\n\nko.observable['fn'] = {\n    \"equalityComparer\": function valuesArePrimitiveAndEqual(a, b) {\n        var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);\n        return oldValueIsPrimitive ? (a === b) : false;\n    }\n};\n\nvar protoProperty = ko.observable.protoProperty = \"__ko_proto__\";\nko.observable['fn'][protoProperty] = ko.observable;\n\nko.hasPrototype = function(instance, prototype) {\n    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;\n    if (instance[protoProperty] === prototype) return true;\n    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain\n};\n\nko.isObservable = function (instance) {\n    return ko.hasPrototype(instance, ko.observable);\n}\nko.isWriteableObservable = function (instance) {\n    // Observable\n    if ((typeof instance == \"function\") && instance[protoProperty] === ko.observable)\n        return true;\n    // Writeable dependent observable\n    if ((typeof instance == \"function\") && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))\n        return true;\n    // Anything else\n    return false;\n}\n\n\nko.exportSymbol('observable', ko.observable);\nko.exportSymbol('isObservable', ko.isObservable);\nko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);\nko.observableArray = function (initialValues) {\n    if (arguments.length == 0) {\n        // Zero-parameter constructor initializes to empty array\n        initialValues = [];\n    }\n    if ((initialValues !== null) && (initialValues !== undefined) && !('length' in initialValues))\n        throw new Error(\"The argument passed when initializing an observable array must be an array, or null, or undefined.\");\n\n    var result = ko.observable(initialValues);\n    ko.utils.extend(result, ko.observableArray['fn']);\n    return result;\n}\n\nko.observableArray['fn'] = {\n    'remove': function (valueOrPredicate) {\n        var underlyingArray = this();\n        var removedValues = [];\n        var predicate = typeof valueOrPredicate == \"function\" ? valueOrPredicate : function (value) { return value === valueOrPredicate; };\n        for (var i = 0; i < underlyingArray.length; i++) {\n            var value = underlyingArray[i];\n            if (predicate(value)) {\n                if (removedValues.length === 0) {\n                    this.valueWillMutate();\n                }\n                removedValues.push(value);\n                underlyingArray.splice(i, 1);\n                i--;\n            }\n        }\n        if (removedValues.length) {\n            this.valueHasMutated();\n        }\n        return removedValues;\n    },\n\n    'removeAll': function (arrayOfValues) {\n        // If you passed zero args, we remove everything\n        if (arrayOfValues === undefined) {\n            var underlyingArray = this();\n            var allValues = underlyingArray.slice(0);\n            this.valueWillMutate();\n            underlyingArray.splice(0, underlyingArray.length);\n            this.valueHasMutated();\n            return allValues;\n        }\n        // If you passed an arg, we interpret it as an array of entries to remove\n        if (!arrayOfValues)\n            return [];\n        return this['remove'](function (value) {\n            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;\n        });\n    },\n\n    'destroy': function (valueOrPredicate) {\n        var underlyingArray = this();\n        var predicate = typeof valueOrPredicate == \"function\" ? valueOrPredicate : function (value) { return value === valueOrPredicate; };\n        this.valueWillMutate();\n        for (var i = underlyingArray.length - 1; i >= 0; i--) {\n            var value = underlyingArray[i];\n            if (predicate(value))\n                underlyingArray[i][\"_destroy\"] = true;\n        }\n        this.valueHasMutated();\n    },\n\n    'destroyAll': function (arrayOfValues) {\n        // If you passed zero args, we destroy everything\n        if (arrayOfValues === undefined)\n            return this['destroy'](function() { return true });\n\n        // If you passed an arg, we interpret it as an array of entries to destroy\n        if (!arrayOfValues)\n            return [];\n        return this['destroy'](function (value) {\n            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;\n        });\n    },\n\n    'indexOf': function (item) {\n        var underlyingArray = this();\n        return ko.utils.arrayIndexOf(underlyingArray, item);\n    },\n\n    'replace': function(oldItem, newItem) {\n        var index = this['indexOf'](oldItem);\n        if (index >= 0) {\n            this.valueWillMutate();\n            this()[index] = newItem;\n            this.valueHasMutated();\n        }\n    }\n}\n\n// Populate ko.observableArray.fn with read/write functions from native arrays\nko.utils.arrayForEach([\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"], function (methodName) {\n    ko.observableArray['fn'][methodName] = function () {\n        var underlyingArray = this();\n        this.valueWillMutate();\n        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);\n        this.valueHasMutated();\n        return methodCallResult;\n    };\n});\n\n// Populate ko.observableArray.fn with read-only functions from native arrays\nko.utils.arrayForEach([\"slice\"], function (methodName) {\n    ko.observableArray['fn'][methodName] = function () {\n        var underlyingArray = this();\n        return underlyingArray[methodName].apply(underlyingArray, arguments);\n    };\n});\n\nko.exportSymbol('observableArray', ko.observableArray);\nko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {\n    var _latestValue,\n        _hasBeenEvaluated = false,\n        _isBeingEvaluated = false,\n        readFunction = evaluatorFunctionOrOptions;\n\n    if (readFunction && typeof readFunction == \"object\") {\n        // Single-parameter syntax - everything is on this \"options\" param\n        options = readFunction;\n        readFunction = options[\"read\"];\n    } else {\n        // Multi-parameter syntax - construct the options according to the params passed\n        options = options || {};\n        if (!readFunction)\n            readFunction = options[\"read\"];\n    }\n    // By here, \"options\" is always non-null\n    if (typeof readFunction != \"function\")\n        throw new Error(\"Pass a function that returns the value of the ko.computed\");\n\n    var writeFunction = options[\"write\"];\n    if (!evaluatorFunctionTarget)\n        evaluatorFunctionTarget = options[\"owner\"];\n\n    var _subscriptionsToDependencies = [];\n    function disposeAllSubscriptionsToDependencies() {\n        ko.utils.arrayForEach(_subscriptionsToDependencies, function (subscription) {\n            subscription.dispose();\n        });\n        _subscriptionsToDependencies = [];\n    }\n    var dispose = disposeAllSubscriptionsToDependencies;\n\n    // Build \"disposeWhenNodeIsRemoved\" and \"disposeWhenNodeIsRemovedCallback\" option values\n    // (Note: \"disposeWhenNodeIsRemoved\" option both proactively disposes as soon as the node is removed using ko.removeNode(),\n    // plus adds a \"disposeWhen\" callback that, on each evaluation, disposes if the node was removed by some other means.)\n    var disposeWhenNodeIsRemoved = (typeof options[\"disposeWhenNodeIsRemoved\"] == \"object\") ? options[\"disposeWhenNodeIsRemoved\"] : null;\n    var disposeWhen = options[\"disposeWhen\"] || function() { return false; };\n    if (disposeWhenNodeIsRemoved) {\n        dispose = function() {\n            ko.utils.domNodeDisposal.removeDisposeCallback(disposeWhenNodeIsRemoved, arguments.callee);\n            disposeAllSubscriptionsToDependencies();\n        };\n        ko.utils.domNodeDisposal.addDisposeCallback(disposeWhenNodeIsRemoved, dispose);\n        var existingDisposeWhenFunction = disposeWhen;\n        disposeWhen = function () {\n            return !ko.utils.domNodeIsAttachedToDocument(disposeWhenNodeIsRemoved) || existingDisposeWhenFunction();\n        }\n    }\n\n    var evaluationTimeoutInstance = null;\n    function evaluatePossiblyAsync() {\n        var throttleEvaluationTimeout = dependentObservable['throttleEvaluation'];\n        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {\n            clearTimeout(evaluationTimeoutInstance);\n            evaluationTimeoutInstance = setTimeout(evaluateImmediate, throttleEvaluationTimeout);\n        } else\n            evaluateImmediate();\n    }\n\n    function evaluateImmediate() {\n        if (_isBeingEvaluated) {\n            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.\n            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost\n            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing\n            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387\n            return;\n        }\n\n        // Don't dispose on first evaluation, because the \"disposeWhen\" callback might\n        // e.g., dispose when the associated DOM element isn't in the doc, and it's not\n        // going to be in the doc until *after* the first evaluation\n        if (_hasBeenEvaluated && disposeWhen()) {\n            dispose();\n            return;\n        }\n\n        _isBeingEvaluated = true;\n        try {\n            // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).\n            // Then, during evaluation, we cross off any that are in fact still being used.\n            var disposalCandidates = ko.utils.arrayMap(_subscriptionsToDependencies, function(item) {return item.target;});\n\n            ko.dependencyDetection.begin(function(subscribable) {\n                var inOld;\n                if ((inOld = ko.utils.arrayIndexOf(disposalCandidates, subscribable)) >= 0)\n                    disposalCandidates[inOld] = undefined; // Don't want to dispose this subscription, as it's still being used\n                else\n                    _subscriptionsToDependencies.push(subscribable.subscribe(evaluatePossiblyAsync)); // Brand new subscription - add it\n            });\n\n            var newValue = readFunction.call(evaluatorFunctionTarget);\n\n            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it\n            for (var i = disposalCandidates.length - 1; i >= 0; i--) {\n                if (disposalCandidates[i])\n                    _subscriptionsToDependencies.splice(i, 1)[0].dispose();\n            }\n            _hasBeenEvaluated = true;\n\n            dependentObservable[\"notifySubscribers\"](_latestValue, \"beforeChange\");\n            _latestValue = newValue;\n            if (DEBUG) dependentObservable._latestValue = _latestValue;\n        } finally {\n            ko.dependencyDetection.end();\n        }\n\n        dependentObservable[\"notifySubscribers\"](_latestValue);\n        _isBeingEvaluated = false;\n\n    }\n\n    function dependentObservable() {\n        if (arguments.length > 0) {\n            set.apply(dependentObservable, arguments);\n        } else {\n            return get();\n        }\n    }\n\n    function set() {\n        if (typeof writeFunction === \"function\") {\n            // Writing a value\n            writeFunction.apply(evaluatorFunctionTarget, arguments);\n        } else {\n            throw new Error(\"Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.\");\n        }\n    }\n\n    function get() {\n        // Reading the value\n        if (!_hasBeenEvaluated)\n            evaluateImmediate();\n        ko.dependencyDetection.registerDependency(dependentObservable);\n        return _latestValue;\n    }\n\n    dependentObservable.getDependenciesCount = function () { return _subscriptionsToDependencies.length; };\n    dependentObservable.hasWriteFunction = typeof options[\"write\"] === \"function\";\n    dependentObservable.dispose = function () { dispose(); };\n\n    ko.subscribable.call(dependentObservable);\n    ko.utils.extend(dependentObservable, ko.dependentObservable['fn']);\n\n    if (options['deferEvaluation'] !== true)\n        evaluateImmediate();\n\n    ko.exportProperty(dependentObservable, 'dispose', dependentObservable.dispose);\n    ko.exportProperty(dependentObservable, 'getDependenciesCount', dependentObservable.getDependenciesCount);\n\n    return dependentObservable;\n};\n\nko.isComputed = function(instance) {\n    return ko.hasPrototype(instance, ko.dependentObservable);\n};\n\nvar protoProp = ko.observable.protoProperty; // == \"__ko_proto__\"\nko.dependentObservable[protoProp] = ko.observable;\n\nko.dependentObservable['fn'] = {};\nko.dependentObservable['fn'][protoProp] = ko.dependentObservable;\n\nko.exportSymbol('dependentObservable', ko.dependentObservable);\nko.exportSymbol('computed', ko.dependentObservable); // Make \"ko.computed\" an alias for \"ko.dependentObservable\"\nko.exportSymbol('isComputed', ko.isComputed);\n\n(function() {\n    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)\n\n    ko.toJS = function(rootObject) {\n        if (arguments.length == 0)\n            throw new Error(\"When calling ko.toJS, pass the object you want to convert.\");\n\n        // We just unwrap everything at every level in the object graph\n        return mapJsObjectGraph(rootObject, function(valueToMap) {\n            // Loop because an observable's value might in turn be another observable wrapper\n            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)\n                valueToMap = valueToMap();\n            return valueToMap;\n        });\n    };\n\n    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional\n        var plainJavaScriptObject = ko.toJS(rootObject);\n        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);\n    };\n\n    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {\n        visitedObjects = visitedObjects || new objectLookup();\n\n        rootObject = mapInputCallback(rootObject);\n        var canHaveProperties = (typeof rootObject == \"object\") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof Date));\n        if (!canHaveProperties)\n            return rootObject;\n\n        var outputProperties = rootObject instanceof Array ? [] : {};\n        visitedObjects.save(rootObject, outputProperties);\n\n        visitPropertiesOrArrayEntries(rootObject, function(indexer) {\n            var propertyValue = mapInputCallback(rootObject[indexer]);\n\n            switch (typeof propertyValue) {\n                case \"boolean\":\n                case \"number\":\n                case \"string\":\n                case \"function\":\n                    outputProperties[indexer] = propertyValue;\n                    break;\n                case \"object\":\n                case \"undefined\":\n                    var previouslyMappedValue = visitedObjects.get(propertyValue);\n                    outputProperties[indexer] = (previouslyMappedValue !== undefined)\n                        ? previouslyMappedValue\n                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);\n                    break;\n            }\n        });\n\n        return outputProperties;\n    }\n\n    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n        if (rootObject instanceof Array) {\n            for (var i = 0; i < rootObject.length; i++)\n                visitorCallback(i);\n\n            // For arrays, also respect toJSON property for custom mappings (fixes #278)\n            if (typeof rootObject['toJSON'] == 'function')\n                visitorCallback('toJSON');\n        } else {\n            for (var propertyName in rootObject)\n                visitorCallback(propertyName);\n        }\n    };\n\n    function objectLookup() {\n        var keys = [];\n        var values = [];\n        this.save = function(key, value) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            if (existingIndex >= 0)\n                values[existingIndex] = value;\n            else {\n                keys.push(key);\n                values.push(value);\n            }\n        };\n        this.get = function(key) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            return (existingIndex >= 0) ? values[existingIndex] : undefined;\n        };\n    };\n})();\n\nko.exportSymbol('toJS', ko.toJS);\nko.exportSymbol('toJSON', ko.toJSON);\n(function () {\n    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';\n\n    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values\n    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values\n    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.\n    ko.selectExtensions = {\n        readValue : function(element) {\n            switch (ko.utils.tagNameLower(element)) {\n                case 'option':\n                    if (element[hasDomDataExpandoProperty] === true)\n                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);\n                    return element.getAttribute(\"value\");\n                case 'select':\n                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;\n                default:\n                    return element.value;\n            }\n        },\n\n        writeValue: function(element, value) {\n            switch (ko.utils.tagNameLower(element)) {\n                case 'option':\n                    switch(typeof value) {\n                        case \"string\":\n                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);\n                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node\n                                delete element[hasDomDataExpandoProperty];\n                            }\n                            element.value = value;\n                            break;\n                        default:\n                            // Store arbitrary object using DomData\n                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);\n                            element[hasDomDataExpandoProperty] = true;\n\n                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.\n                            element.value = typeof value === \"number\" ? value : \"\";\n                            break;\n                    }\n                    break;\n                case 'select':\n                    for (var i = element.options.length - 1; i >= 0; i--) {\n                        if (ko.selectExtensions.readValue(element.options[i]) == value) {\n                            element.selectedIndex = i;\n                            break;\n                        }\n                    }\n                    break;\n                default:\n                    if ((value === null) || (value === undefined))\n                        value = \"\";\n                    element.value = value;\n                    break;\n            }\n        }\n    };\n})();\n\nko.exportSymbol('selectExtensions', ko.selectExtensions);\nko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);\nko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);\n\nko.jsonExpressionRewriting = (function () {\n    var restoreCapturedTokensRegex = /\\@ko_token_(\\d+)\\@/g;\n    var javaScriptAssignmentTarget = /^[\\_$a-z][\\_$a-z0-9]*(\\[.*?\\])*(\\.[\\_$a-z][\\_$a-z0-9]*(\\[.*?\\])*)*$/i;\n    var javaScriptReservedWords = [\"true\", \"false\"];\n\n    function restoreTokens(string, tokens) {\n        var prevValue = null;\n        while (string != prevValue) { // Keep restoring tokens until it no longer makes a difference (they may be nested)\n            prevValue = string;\n            string = string.replace(restoreCapturedTokensRegex, function (match, tokenIndex) {\n                return tokens[tokenIndex];\n            });\n        }\n        return string;\n    }\n\n    function isWriteableValue(expression) {\n        if (ko.utils.arrayIndexOf(javaScriptReservedWords, ko.utils.stringTrim(expression).toLowerCase()) >= 0)\n            return false;\n        return expression.match(javaScriptAssignmentTarget) !== null;\n    }\n\n    function ensureQuoted(key) {\n        var trimmedKey = ko.utils.stringTrim(key);\n        switch (trimmedKey.length && trimmedKey.charAt(0)) {\n            case \"'\":\n            case '\"':\n                return key;\n            default:\n                return \"'\" + trimmedKey + \"'\";\n        }\n    }\n\n    return {\n        bindingRewriteValidators: [],\n\n        parseObjectLiteral: function(objectLiteralString) {\n            // A full tokeniser+lexer would add too much weight to this library, so here's a simple parser\n            // that is sufficient just to split an object literal string into a set of top-level key-value pairs\n\n            var str = ko.utils.stringTrim(objectLiteralString);\n            if (str.length < 3)\n                return [];\n            if (str.charAt(0) === \"{\")// Ignore any braces surrounding the whole object literal\n                str = str.substring(1, str.length - 1);\n\n            // Pull out any string literals and regex literals\n            var tokens = [];\n            var tokenStart = null, tokenEndChar;\n            for (var position = 0; position < str.length; position++) {\n                var c = str.charAt(position);\n                if (tokenStart === null) {\n                    switch (c) {\n                        case '\"':\n                        case \"'\":\n                        case \"/\":\n                            tokenStart = position;\n                            tokenEndChar = c;\n                            break;\n                    }\n                } else if ((c == tokenEndChar) && (str.charAt(position - 1) !== \"\\\\\")) {\n                    var token = str.substring(tokenStart, position + 1);\n                    tokens.push(token);\n                    var replacement = \"@ko_token_\" + (tokens.length - 1) + \"@\";\n                    str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);\n                    position -= (token.length - replacement.length);\n                    tokenStart = null;\n                }\n            }\n\n            // Next pull out balanced paren, brace, and bracket blocks\n            tokenStart = null;\n            tokenEndChar = null;\n            var tokenDepth = 0, tokenStartChar = null;\n            for (var position = 0; position < str.length; position++) {\n                var c = str.charAt(position);\n                if (tokenStart === null) {\n                    switch (c) {\n                        case \"{\": tokenStart = position; tokenStartChar = c;\n                                  tokenEndChar = \"}\";\n                                  break;\n                        case \"(\": tokenStart = position; tokenStartChar = c;\n                                  tokenEndChar = \")\";\n                                  break;\n                        case \"[\": tokenStart = position; tokenStartChar = c;\n                                  tokenEndChar = \"]\";\n                                  break;\n                    }\n                }\n\n                if (c === tokenStartChar)\n                    tokenDepth++;\n                else if (c === tokenEndChar) {\n                    tokenDepth--;\n                    if (tokenDepth === 0) {\n                        var token = str.substring(tokenStart, position + 1);\n                        tokens.push(token);\n                        var replacement = \"@ko_token_\" + (tokens.length - 1) + \"@\";\n                        str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);\n                        position -= (token.length - replacement.length);\n                        tokenStart = null;\n                    }\n                }\n            }\n\n            // Now we can safely split on commas to get the key/value pairs\n            var result = [];\n            var keyValuePairs = str.split(\",\");\n            for (var i = 0, j = keyValuePairs.length; i < j; i++) {\n                var pair = keyValuePairs[i];\n                var colonPos = pair.indexOf(\":\");\n                if ((colonPos > 0) && (colonPos < pair.length - 1)) {\n                    var key = pair.substring(0, colonPos);\n                    var value = pair.substring(colonPos + 1);\n                    result.push({ 'key': restoreTokens(key, tokens), 'value': restoreTokens(value, tokens) });\n                } else {\n                    result.push({ 'unknown': restoreTokens(pair, tokens) });\n                }\n            }\n            return result;\n        },\n\n        insertPropertyAccessorsIntoJson: function (objectLiteralStringOrKeyValueArray) {\n            var keyValueArray = typeof objectLiteralStringOrKeyValueArray === \"string\"\n                ? ko.jsonExpressionRewriting.parseObjectLiteral(objectLiteralStringOrKeyValueArray)\n                : objectLiteralStringOrKeyValueArray;\n            var resultStrings = [], propertyAccessorResultStrings = [];\n\n            var keyValueEntry;\n            for (var i = 0; keyValueEntry = keyValueArray[i]; i++) {\n                if (resultStrings.length > 0)\n                    resultStrings.push(\",\");\n\n                if (keyValueEntry['key']) {\n                    var quotedKey = ensureQuoted(keyValueEntry['key']), val = keyValueEntry['value'];\n                    resultStrings.push(quotedKey);\n                    resultStrings.push(\":\");\n                    resultStrings.push(val);\n\n                    if (isWriteableValue(ko.utils.stringTrim(val))) {\n                        if (propertyAccessorResultStrings.length > 0)\n                            propertyAccessorResultStrings.push(\", \");\n                        propertyAccessorResultStrings.push(quotedKey + \" : function(__ko_value) { \" + val + \" = __ko_value; }\");\n                    }\n                } else if (keyValueEntry['unknown']) {\n                    resultStrings.push(keyValueEntry['unknown']);\n                }\n            }\n\n            var combinedResult = resultStrings.join(\"\");\n            if (propertyAccessorResultStrings.length > 0) {\n                var allPropertyAccessors = propertyAccessorResultStrings.join(\"\");\n                combinedResult = combinedResult + \", '_ko_property_writers' : { \" + allPropertyAccessors + \" } \";\n            }\n\n            return combinedResult;\n        },\n\n        keyValueArrayContainsKey: function(keyValueArray, key) {\n            for (var i = 0; i < keyValueArray.length; i++)\n                if (ko.utils.stringTrim(keyValueArray[i]['key']) == key)\n                    return true;\n            return false;\n        },\n\n        // Internal, private KO utility for updating model properties from within bindings\n        // property:            If the property being updated is (or might be) an observable, pass it here\n        //                      If it turns out to be a writable observable, it will be written to directly\n        // allBindingsAccessor: All bindings in the current execution context.\n        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable\n        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'\n        // value:               The value to be written\n        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if\n        //                      it is !== existing value on that writable observable\n        writeValueToProperty: function(property, allBindingsAccessor, key, value, checkIfDifferent) {\n            if (!property || !ko.isWriteableObservable(property)) {\n                var propWriters = allBindingsAccessor()['_ko_property_writers'];\n                if (propWriters && propWriters[key])\n                    propWriters[key](value);\n            } else if (!checkIfDifferent || property() !== value) {\n                property(value);\n            }\n        }\n    };\n})();\n\nko.exportSymbol('jsonExpressionRewriting', ko.jsonExpressionRewriting);\nko.exportSymbol('jsonExpressionRewriting.bindingRewriteValidators', ko.jsonExpressionRewriting.bindingRewriteValidators);\nko.exportSymbol('jsonExpressionRewriting.parseObjectLiteral', ko.jsonExpressionRewriting.parseObjectLiteral);\nko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson);\n(function() {\n    // \"Virtual elements\" is an abstraction on top of the usual DOM API which understands the notion that comment nodes\n    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).\n    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state\n    // of that virtual hierarchy\n    //\n    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)\n    // without having to scatter special cases all over the binding and templating code.\n\n    // IE 9 cannot reliably read the \"nodeValue\" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)\n    // but it does give them a nonstandard alternative property called \"text\" that it can read reliably. Other browsers don't have that property.\n    // So, use node.text where available, and node.nodeValue elsewhere\n    var commentNodesHaveTextProperty = document.createComment(\"test\").text === \"<!--test-->\";\n\n    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\\s*ko\\s+(.*\\:.*)\\s*-->$/ : /^\\s*ko\\s+(.*\\:.*)\\s*$/;\n    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\\s*\\/ko\\s*-->$/ : /^\\s*\\/ko\\s*$/;\n    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };\n\n    function isStartComment(node) {\n        return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);\n    }\n\n    function isEndComment(node) {\n        return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(endCommentRegex);\n    }\n\n    function getVirtualChildren(startComment, allowUnbalanced) {\n        var currentNode = startComment;\n        var depth = 1;\n        var children = [];\n        while (currentNode = currentNode.nextSibling) {\n            if (isEndComment(currentNode)) {\n                depth--;\n                if (depth === 0)\n                    return children;\n            }\n\n            children.push(currentNode);\n\n            if (isStartComment(currentNode))\n                depth++;\n        }\n        if (!allowUnbalanced)\n            throw new Error(\"Cannot find closing comment tag to match: \" + startComment.nodeValue);\n        return null;\n    }\n\n    function getMatchingEndComment(startComment, allowUnbalanced) {\n        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);\n        if (allVirtualChildren) {\n            if (allVirtualChildren.length > 0)\n                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;\n            return startComment.nextSibling;\n        } else\n            return null; // Must have no matching end comment, and allowUnbalanced is true\n    }\n\n    function getUnbalancedChildTags(node) {\n        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>\n        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->\n        var childNode = node.firstChild, captureRemaining = null;\n        if (childNode) {\n            do {\n                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes\n                    captureRemaining.push(childNode);\n                else if (isStartComment(childNode)) {\n                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);\n                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set\n                        childNode = matchingEndComment;\n                    else\n                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point\n                } else if (isEndComment(childNode)) {\n                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing\n                }\n            } while (childNode = childNode.nextSibling);\n        }\n        return captureRemaining;\n    }\n\n    ko.virtualElements = {\n        allowedBindings: {},\n\n        childNodes: function(node) {\n            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;\n        },\n\n        emptyNode: function(node) {\n            if (!isStartComment(node))\n                ko.utils.emptyDomNode(node);\n            else {\n                var virtualChildren = ko.virtualElements.childNodes(node);\n                for (var i = 0, j = virtualChildren.length; i < j; i++)\n                    ko.removeNode(virtualChildren[i]);\n            }\n        },\n\n        setDomNodeChildren: function(node, childNodes) {\n            if (!isStartComment(node))\n                ko.utils.setDomNodeChildren(node, childNodes);\n            else {\n                ko.virtualElements.emptyNode(node);\n                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children\n                for (var i = 0, j = childNodes.length; i < j; i++)\n                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);\n            }\n        },\n\n        prepend: function(containerNode, nodeToPrepend) {\n            if (!isStartComment(containerNode)) {\n                if (containerNode.firstChild)\n                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);\n                else\n                    containerNode.appendChild(nodeToPrepend);\n            } else {\n                // Start comments must always have a parent and at least one following sibling (the end comment)\n                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);\n            }\n        },\n\n        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {\n            if (!isStartComment(containerNode)) {\n                // Insert after insertion point\n                if (insertAfterNode.nextSibling)\n                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);\n                else\n                    containerNode.appendChild(nodeToInsert);\n            } else {\n                // Children of start comments must always have a parent and at least one following sibling (the end comment)\n                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);\n            }\n        },\n\n        firstChild: function(node) {\n            if (!isStartComment(node))\n                return node.firstChild;\n            if (!node.nextSibling || isEndComment(node.nextSibling))\n                return null;\n            return node.nextSibling;\n        },\n\n        nextSibling: function(node) {\n            if (isStartComment(node))\n                node = getMatchingEndComment(node);\n            if (node.nextSibling && isEndComment(node.nextSibling))\n                return null;\n            return node.nextSibling;\n        },\n\n        virtualNodeBindingValue: function(node) {\n            var regexMatch = isStartComment(node);\n            return regexMatch ? regexMatch[1] : null;\n        },\n\n        normaliseVirtualElementDomStructure: function(elementVerified) {\n            // Workaround for https://github.com/SteveSanderson/knockout/issues/155\n            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes\n            // that are direct descendants of <ul> into the preceding <li>)\n            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])\n                return;\n\n            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags\n            // must be intended to appear *after* that child, so move them there.\n            var childNode = elementVerified.firstChild;\n            if (childNode) {\n                do {\n                    if (childNode.nodeType === 1) {\n                        var unbalancedTags = getUnbalancedChildTags(childNode);\n                        if (unbalancedTags) {\n                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child\n                            var nodeToInsertBefore = childNode.nextSibling;\n                            for (var i = 0; i < unbalancedTags.length; i++) {\n                                if (nodeToInsertBefore)\n                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);\n                                else\n                                    elementVerified.appendChild(unbalancedTags[i]);\n                            }\n                        }\n                    }\n                } while (childNode = childNode.nextSibling);\n            }\n        }\n    };\n})();\nko.exportSymbol('virtualElements', ko.virtualElements);\nko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);\nko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);\n//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified\nko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);\n//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified\nko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);\nko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);\n(function() {\n    var defaultBindingAttributeName = \"data-bind\";\n\n    ko.bindingProvider = function() {\n        this.bindingCache = {};\n    };\n\n    ko.utils.extend(ko.bindingProvider.prototype, {\n        'nodeHasBindings': function(node) {\n            switch (node.nodeType) {\n                case 1: return node.getAttribute(defaultBindingAttributeName) != null;   // Element\n                case 8: return ko.virtualElements.virtualNodeBindingValue(node) != null; // Comment node\n                default: return false;\n            }\n        },\n\n        'getBindings': function(node, bindingContext) {\n            var bindingsString = this['getBindingsString'](node, bindingContext);\n            return bindingsString ? this['parseBindingsString'](bindingsString, bindingContext) : null;\n        },\n\n        // The following function is only used internally by this default provider.\n        // It's not part of the interface definition for a general binding provider.\n        'getBindingsString': function(node, bindingContext) {\n            switch (node.nodeType) {\n                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element\n                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node\n                default: return null;\n            }\n        },\n\n        // The following function is only used internally by this default provider.\n        // It's not part of the interface definition for a general binding provider.\n        'parseBindingsString': function(bindingsString, bindingContext) {\n            try {\n                var viewModel = bindingContext['$data'],\n                    scopes = (typeof viewModel == 'object' && viewModel != null) ? [viewModel, bindingContext] : [bindingContext],\n                    bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, scopes.length, this.bindingCache);\n                return bindingFunction(scopes);\n            } catch (ex) {\n                throw new Error(\"Unable to parse bindings.\\nMessage: \" + ex + \";\\nBindings value: \" + bindingsString);\n            }\n        }\n    });\n\n    ko.bindingProvider['instance'] = new ko.bindingProvider();\n\n    function createBindingsStringEvaluatorViaCache(bindingsString, scopesCount, cache) {\n        var cacheKey = scopesCount + '_' + bindingsString;\n        return cache[cacheKey]\n            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, scopesCount));\n    }\n\n    function createBindingsStringEvaluator(bindingsString, scopesCount) {\n        var rewrittenBindings = \" { \" + ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson(bindingsString) + \" } \";\n        return ko.utils.buildEvalWithinScopeFunction(rewrittenBindings, scopesCount);\n    }\n})();\n\nko.exportSymbol('bindingProvider', ko.bindingProvider);\n(function () {\n    ko.bindingHandlers = {};\n\n    ko.bindingContext = function(dataItem, parentBindingContext) {\n        if (parentBindingContext) {\n            ko.utils.extend(this, parentBindingContext); // Inherit $root and any custom properties\n            this['$parentContext'] = parentBindingContext;\n            this['$parent'] = parentBindingContext['$data'];\n            this['$parents'] = (parentBindingContext['$parents'] || []).slice(0);\n            this['$parents'].unshift(this['$parent']);\n        } else {\n            this['$parents'] = [];\n            this['$root'] = dataItem;\n        }\n        this['$data'] = dataItem;\n    }\n    ko.bindingContext.prototype['createChildContext'] = function (dataItem) {\n        return new ko.bindingContext(dataItem, this);\n    };\n    ko.bindingContext.prototype['extend'] = function(properties) {\n        var clone = ko.utils.extend(new ko.bindingContext(), this);\n        return ko.utils.extend(clone, properties);\n    };\n\n    function validateThatBindingIsAllowedForVirtualElements(bindingName) {\n        var validator = ko.virtualElements.allowedBindings[bindingName];\n        if (!validator)\n            throw new Error(\"The binding '\" + bindingName + \"' cannot be used with virtual elements\")\n    }\n\n    function applyBindingsToDescendantsInternal (viewModel, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {\n        var currentChild, nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);\n        while (currentChild = nextInQueue) {\n            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position\n            nextInQueue = ko.virtualElements.nextSibling(currentChild);\n            applyBindingsToNodeAndDescendantsInternal(viewModel, currentChild, bindingContextsMayDifferFromDomParentElement);\n        }\n    }\n\n    function applyBindingsToNodeAndDescendantsInternal (viewModel, nodeVerified, bindingContextMayDifferFromDomParentElement) {\n        var shouldBindDescendants = true;\n\n        // Perf optimisation: Apply bindings only if...\n        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)\n        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those\n        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)\n        var isElement = (nodeVerified.nodeType === 1);\n        if (isElement) // Workaround IE <= 8 HTML parsing weirdness\n            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);\n\n        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)\n                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)\n        if (shouldApplyBindings)\n            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, viewModel, bindingContextMayDifferFromDomParentElement).shouldBindDescendants;\n\n        if (shouldBindDescendants) {\n            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,\n            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,\n            //    hence bindingContextsMayDifferFromDomParentElement is false\n            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may\n            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,\n            //    hence bindingContextsMayDifferFromDomParentElement is true\n            applyBindingsToDescendantsInternal(viewModel, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);\n        }\n    }\n\n    function applyBindingsToNodeInternal (node, bindings, viewModelOrBindingContext, bindingContextMayDifferFromDomParentElement) {\n        // Need to be sure that inits are only run once, and updates never run until all the inits have been run\n        var initPhase = 0; // 0 = before all inits, 1 = during inits, 2 = after all inits\n\n        // Each time the dependentObservable is evaluated (after data changes),\n        // the binding attribute is reparsed so that it can pick out the correct\n        // model properties in the context of the changed data.\n        // DOM event callbacks need to be able to access this changed data,\n        // so we need a single parsedBindings variable (shared by all callbacks\n        // associated with this node's bindings) that all the closures can access.\n        var parsedBindings;\n        function makeValueAccessor(bindingKey) {\n            return function () { return parsedBindings[bindingKey] }\n        }\n        function parsedBindingsAccessor() {\n            return parsedBindings;\n        }\n\n        var bindingHandlerThatControlsDescendantBindings;\n        ko.dependentObservable(\n            function () {\n                // Ensure we have a nonnull binding context to work with\n                var bindingContextInstance = viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)\n                    ? viewModelOrBindingContext\n                    : new ko.bindingContext(ko.utils.unwrapObservable(viewModelOrBindingContext));\n                var viewModel = bindingContextInstance['$data'];\n\n                // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because\n                // we can easily recover it just by scanning up the node's ancestors in the DOM\n                // (note: here, parent node means \"real DOM parent\" not \"virtual parent\", as there's no O(1) way to find the virtual parent)\n                if (bindingContextMayDifferFromDomParentElement)\n                    ko.storedBindingContextForNode(node, bindingContextInstance);\n\n                // Use evaluatedBindings if given, otherwise fall back on asking the bindings provider to give us some bindings\n                var evaluatedBindings = (typeof bindings == \"function\") ? bindings() : bindings;\n                parsedBindings = evaluatedBindings || ko.bindingProvider['instance']['getBindings'](node, bindingContextInstance);\n\n                if (parsedBindings) {\n                    // First run all the inits, so bindings can register for notification on changes\n                    if (initPhase === 0) {\n                        initPhase = 1;\n                        for (var bindingKey in parsedBindings) {\n                            var binding = ko.bindingHandlers[bindingKey];\n                            if (binding && node.nodeType === 8)\n                                validateThatBindingIsAllowedForVirtualElements(bindingKey);\n\n                            if (binding && typeof binding[\"init\"] == \"function\") {\n                                var handlerInitFn = binding[\"init\"];\n                                var initResult = handlerInitFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);\n\n                                // If this binding handler claims to control descendant bindings, make a note of this\n                                if (initResult && initResult['controlsDescendantBindings']) {\n                                    if (bindingHandlerThatControlsDescendantBindings !== undefined)\n                                        throw new Error(\"Multiple bindings (\" + bindingHandlerThatControlsDescendantBindings + \" and \" + bindingKey + \") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.\");\n                                    bindingHandlerThatControlsDescendantBindings = bindingKey;\n                                }\n                            }\n                        }\n                        initPhase = 2;\n                    }\n\n                    // ... then run all the updates, which might trigger changes even on the first evaluation\n                    if (initPhase === 2) {\n                        for (var bindingKey in parsedBindings) {\n                            var binding = ko.bindingHandlers[bindingKey];\n                            if (binding && typeof binding[\"update\"] == \"function\") {\n                                var handlerUpdateFn = binding[\"update\"];\n                                handlerUpdateFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);\n                            }\n                        }\n                    }\n                }\n            },\n            null,\n            { 'disposeWhenNodeIsRemoved' : node }\n        );\n\n        return {\n            shouldBindDescendants: bindingHandlerThatControlsDescendantBindings === undefined\n        };\n    };\n\n    var storedBindingContextDomDataKey = \"__ko_bindingContext__\";\n    ko.storedBindingContextForNode = function (node, bindingContext) {\n        if (arguments.length == 2)\n            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);\n        else\n            return ko.utils.domData.get(node, storedBindingContextDomDataKey);\n    }\n\n    ko.applyBindingsToNode = function (node, bindings, viewModel) {\n        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness\n            ko.virtualElements.normaliseVirtualElementDomStructure(node);\n        return applyBindingsToNodeInternal(node, bindings, viewModel, true);\n    };\n\n    ko.applyBindingsToDescendants = function(viewModel, rootNode) {\n        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)\n            applyBindingsToDescendantsInternal(viewModel, rootNode, true);\n    };\n\n    ko.applyBindings = function (viewModel, rootNode) {\n        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))\n            throw new Error(\"ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node\");\n        rootNode = rootNode || window.document.body; // Make \"rootNode\" parameter optional\n\n        applyBindingsToNodeAndDescendantsInternal(viewModel, rootNode, true);\n    };\n\n    // Retrieving binding context from arbitrary nodes\n    ko.contextFor = function(node) {\n        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)\n        switch (node.nodeType) {\n            case 1:\n            case 8:\n                var context = ko.storedBindingContextForNode(node);\n                if (context) return context;\n                if (node.parentNode) return ko.contextFor(node.parentNode);\n                break;\n        }\n        return undefined;\n    };\n    ko.dataFor = function(node) {\n        var context = ko.contextFor(node);\n        return context ? context['$data'] : undefined;\n    };\n\n    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);\n    ko.exportSymbol('applyBindings', ko.applyBindings);\n    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);\n    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);\n    ko.exportSymbol('contextFor', ko.contextFor);\n    ko.exportSymbol('dataFor', ko.dataFor);\n})();\n// For certain common events (currently just 'click'), allow a simplified data-binding syntax\n// e.g. click:handler instead of the usual full-length event:{click:handler}\nvar eventHandlersWithShortcuts = ['click'];\nko.utils.arrayForEach(eventHandlersWithShortcuts, function(eventName) {\n    ko.bindingHandlers[eventName] = {\n        'init': function(element, valueAccessor, allBindingsAccessor, viewModel) {\n            var newValueAccessor = function () {\n                var result = {};\n                result[eventName] = valueAccessor();\n                return result;\n            };\n            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindingsAccessor, viewModel);\n        }\n    }\n});\n\n\nko.bindingHandlers['event'] = {\n    'init' : function (element, valueAccessor, allBindingsAccessor, viewModel) {\n        var eventsToHandle = valueAccessor() || {};\n        for(var eventNameOutsideClosure in eventsToHandle) {\n            (function() {\n                var eventName = eventNameOutsideClosure; // Separate variable to be captured by event handler closure\n                if (typeof eventName == \"string\") {\n                    ko.utils.registerEventHandler(element, eventName, function (event) {\n                        var handlerReturnValue;\n                        var handlerFunction = valueAccessor()[eventName];\n                        if (!handlerFunction)\n                            return;\n                        var allBindings = allBindingsAccessor();\n\n                        try {\n                            // Take all the event args, and prefix with the viewmodel\n                            var argsForHandler = ko.utils.makeArray(arguments);\n                            argsForHandler.unshift(viewModel);\n                            handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);\n                        } finally {\n                            if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.\n                                if (event.preventDefault)\n                                    event.preventDefault();\n                                else\n                                    event.returnValue = false;\n                            }\n                        }\n\n                        var bubble = allBindings[eventName + 'Bubble'] !== false;\n                        if (!bubble) {\n                            event.cancelBubble = true;\n                            if (event.stopPropagation)\n                                event.stopPropagation();\n                        }\n                    });\n                }\n            })();\n        }\n    }\n};\n\nko.bindingHandlers['submit'] = {\n    'init': function (element, valueAccessor, allBindingsAccessor, viewModel) {\n        if (typeof valueAccessor() != \"function\")\n            throw new Error(\"The value for a submit binding must be a function\");\n        ko.utils.registerEventHandler(element, \"submit\", function (event) {\n            var handlerReturnValue;\n            var value = valueAccessor();\n            try { handlerReturnValue = value.call(viewModel, element); }\n            finally {\n                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.\n                    if (event.preventDefault)\n                        event.preventDefault();\n                    else\n                        event.returnValue = false;\n                }\n            }\n        });\n    }\n};\n\nko.bindingHandlers['visible'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        var isCurrentlyVisible = !(element.style.display == \"none\");\n        if (value && !isCurrentlyVisible)\n            element.style.display = \"\";\n        else if ((!value) && isCurrentlyVisible)\n            element.style.display = \"none\";\n    }\n}\n\nko.bindingHandlers['enable'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        if (value && element.disabled)\n            element.removeAttribute(\"disabled\");\n        else if ((!value) && (!element.disabled))\n            element.disabled = true;\n    }\n};\n\nko.bindingHandlers['disable'] = {\n    'update': function (element, valueAccessor) {\n        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });\n    }\n};\n\nfunction ensureDropdownSelectionIsConsistentWithModelValue(element, modelValue, preferModelValue) {\n    if (preferModelValue) {\n        if (modelValue !== ko.selectExtensions.readValue(element))\n            ko.selectExtensions.writeValue(element, modelValue);\n    }\n\n    // No matter which direction we're syncing in, we want the end result to be equality between dropdown value and model value.\n    // If they aren't equal, either we prefer the dropdown value, or the model value couldn't be represented, so either way,\n    // change the model value to match the dropdown.\n    if (modelValue !== ko.selectExtensions.readValue(element))\n        ko.utils.triggerEvent(element, \"change\");\n};\n\nko.bindingHandlers['value'] = {\n    'init': function (element, valueAccessor, allBindingsAccessor) {\n        // Always catch \"change\" event; possibly other events too if asked\n        var eventsToCatch = [\"change\"];\n        var requestedEventsToCatch = allBindingsAccessor()[\"valueUpdate\"];\n        if (requestedEventsToCatch) {\n            if (typeof requestedEventsToCatch == \"string\") // Allow both individual event names, and arrays of event names\n                requestedEventsToCatch = [requestedEventsToCatch];\n            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);\n            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);\n        }\n\n        var valueUpdateHandler = function() {\n            var modelValue = valueAccessor();\n            var elementValue = ko.selectExtensions.readValue(element);\n            ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'value', elementValue, /* checkIfDifferent: */ true);\n        }\n\n        // Workaround for https://github.com/SteveSanderson/knockout/issues/122\n        // IE doesn't fire \"change\" events on textboxes if the user selects a value from its autocomplete list\n        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == \"input\" && element.type == \"text\"\n                                       && element.autocomplete != \"off\" && (!element.form || element.form.autocomplete != \"off\");\n        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, \"propertychange\") == -1) {\n            var propertyChangedFired = false;\n            ko.utils.registerEventHandler(element, \"propertychange\", function () { propertyChangedFired = true });\n            ko.utils.registerEventHandler(element, \"blur\", function() {\n                if (propertyChangedFired) {\n                    propertyChangedFired = false;\n                    valueUpdateHandler();\n                }\n            });\n        }\n\n        ko.utils.arrayForEach(eventsToCatch, function(eventName) {\n            // The syntax \"after<eventname>\" means \"run the handler asynchronously after the event\"\n            // This is useful, for example, to catch \"keydown\" events after the browser has updated the control\n            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)\n            var handler = valueUpdateHandler;\n            if (ko.utils.stringStartsWith(eventName, \"after\")) {\n                handler = function() { setTimeout(valueUpdateHandler, 0) };\n                eventName = eventName.substring(\"after\".length);\n            }\n            ko.utils.registerEventHandler(element, eventName, handler);\n        });\n    },\n    'update': function (element, valueAccessor) {\n        var valueIsSelectOption = ko.utils.tagNameLower(element) === \"select\";\n        var newValue = ko.utils.unwrapObservable(valueAccessor());\n        var elementValue = ko.selectExtensions.readValue(element);\n        var valueHasChanged = (newValue != elementValue);\n\n        // JavaScript's 0 == \"\" behavious is unfortunate here as it prevents writing 0 to an empty text box (loose equality suggests the values are the same).\n        // We don't want to do a strict equality comparison as that is more confusing for developers in certain cases, so we specifically special case 0 != \"\" here.\n        if ((newValue === 0) && (elementValue !== 0) && (elementValue !== \"0\"))\n            valueHasChanged = true;\n\n        if (valueHasChanged) {\n            var applyValueAction = function () { ko.selectExtensions.writeValue(element, newValue); };\n            applyValueAction();\n\n            // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread\n            // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread\n            // to apply the value as well.\n            var alsoApplyAsynchronously = valueIsSelectOption;\n            if (alsoApplyAsynchronously)\n                setTimeout(applyValueAction, 0);\n        }\n\n        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,\n        // because you're not allowed to have a model value that disagrees with a visible UI selection.\n        if (valueIsSelectOption && (element.length > 0))\n            ensureDropdownSelectionIsConsistentWithModelValue(element, newValue, /* preferModelValue */ false);\n    }\n};\n\nko.bindingHandlers['options'] = {\n    'update': function (element, valueAccessor, allBindingsAccessor) {\n        if (ko.utils.tagNameLower(element) !== \"select\")\n            throw new Error(\"options binding applies only to SELECT elements\");\n\n        var selectWasPreviouslyEmpty = element.length == 0;\n        var previousSelectedValues = ko.utils.arrayMap(ko.utils.arrayFilter(element.childNodes, function (node) {\n            return node.tagName && (ko.utils.tagNameLower(node) === \"option\") && node.selected;\n        }), function (node) {\n            return ko.selectExtensions.readValue(node) || node.innerText || node.textContent;\n        });\n        var previousScrollTop = element.scrollTop;\n\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        var selectedValue = element.value;\n\n        // Remove all existing <option>s.\n        // Need to use .remove() rather than .removeChild() for <option>s otherwise IE behaves oddly (https://github.com/SteveSanderson/knockout/issues/134)\n        while (element.length > 0) {\n            ko.cleanNode(element.options[0]);\n            element.remove(0);\n        }\n\n        if (value) {\n            var allBindings = allBindingsAccessor();\n            if (typeof value.length != \"number\")\n                value = [value];\n            if (allBindings['optionsCaption']) {\n                var option = document.createElement(\"option\");\n                ko.utils.setHtml(option, allBindings['optionsCaption']);\n                ko.selectExtensions.writeValue(option, undefined);\n                element.appendChild(option);\n            }\n            for (var i = 0, j = value.length; i < j; i++) {\n                var option = document.createElement(\"option\");\n\n                // Apply a value to the option element\n                var optionValue = typeof allBindings['optionsValue'] == \"string\" ? value[i][allBindings['optionsValue']] : value[i];\n                optionValue = ko.utils.unwrapObservable(optionValue);\n                ko.selectExtensions.writeValue(option, optionValue);\n\n                // Apply some text to the option element\n                var optionsTextValue = allBindings['optionsText'];\n                var optionText;\n                if (typeof optionsTextValue == \"function\")\n                    optionText = optionsTextValue(value[i]); // Given a function; run it against the data value\n                else if (typeof optionsTextValue == \"string\")\n                    optionText = value[i][optionsTextValue]; // Given a string; treat it as a property name on the data value\n                else\n                    optionText = optionValue;                // Given no optionsText arg; use the data value itself\n                if ((optionText === null) || (optionText === undefined))\n                    optionText = \"\";\n\n                ko.utils.setTextContent(option, optionText);\n\n                element.appendChild(option);\n            }\n\n            // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.\n            // That's why we first added them without selection. Now it's time to set the selection.\n            var newOptions = element.getElementsByTagName(\"option\");\n            var countSelectionsRetained = 0;\n            for (var i = 0, j = newOptions.length; i < j; i++) {\n                if (ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[i])) >= 0) {\n                    ko.utils.setOptionNodeSelectionState(newOptions[i], true);\n                    countSelectionsRetained++;\n                }\n            }\n\n            element.scrollTop = previousScrollTop;\n\n            if (selectWasPreviouslyEmpty && ('value' in allBindings)) {\n                // Ensure consistency between model value and selected option.\n                // If the dropdown is being populated for the first time here (or was otherwise previously empty),\n                // the dropdown selection state is meaningless, so we preserve the model value.\n                ensureDropdownSelectionIsConsistentWithModelValue(element, ko.utils.unwrapObservable(allBindings['value']), /* preferModelValue */ true);\n            }\n\n            // Workaround for IE9 bug\n            ko.utils.ensureSelectElementIsRenderedCorrectly(element);\n        }\n    }\n};\nko.bindingHandlers['options'].optionValueDomDataKey = '__ko.optionValueDomData__';\n\nko.bindingHandlers['selectedOptions'] = {\n    getSelectedValuesFromSelectNode: function (selectNode) {\n        var result = [];\n        var nodes = selectNode.childNodes;\n        for (var i = 0, j = nodes.length; i < j; i++) {\n            var node = nodes[i], tagName = ko.utils.tagNameLower(node);\n            if (tagName == \"option\" && node.selected)\n                result.push(ko.selectExtensions.readValue(node));\n            else if (tagName == \"optgroup\") {\n                var selectedValuesFromOptGroup = ko.bindingHandlers['selectedOptions'].getSelectedValuesFromSelectNode(node);\n                Array.prototype.splice.apply(result, [result.length, 0].concat(selectedValuesFromOptGroup)); // Add new entries to existing 'result' instance\n            }\n        }\n        return result;\n    },\n    'init': function (element, valueAccessor, allBindingsAccessor) {\n        ko.utils.registerEventHandler(element, \"change\", function () {\n            var value = valueAccessor();\n            var valueToWrite = ko.bindingHandlers['selectedOptions'].getSelectedValuesFromSelectNode(this);\n            ko.jsonExpressionRewriting.writeValueToProperty(value, allBindingsAccessor, 'value', valueToWrite);\n        });\n    },\n    'update': function (element, valueAccessor) {\n        if (ko.utils.tagNameLower(element) != \"select\")\n            throw new Error(\"values binding applies only to SELECT elements\");\n\n        var newValue = ko.utils.unwrapObservable(valueAccessor());\n        if (newValue && typeof newValue.length == \"number\") {\n            var nodes = element.childNodes;\n            for (var i = 0, j = nodes.length; i < j; i++) {\n                var node = nodes[i];\n                if (ko.utils.tagNameLower(node) === \"option\")\n                    ko.utils.setOptionNodeSelectionState(node, ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0);\n            }\n        }\n    }\n};\n\nko.bindingHandlers['text'] = {\n    'update': function (element, valueAccessor) {\n        ko.utils.setTextContent(element, valueAccessor());\n    }\n};\n\nko.bindingHandlers['html'] = {\n    'init': function() {\n        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)\n        return { 'controlsDescendantBindings': true };\n    },\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        ko.utils.setHtml(element, value);\n    }\n};\n\nko.bindingHandlers['css'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor() || {});\n        for (var className in value) {\n            if (typeof className == \"string\") {\n                var shouldHaveClass = ko.utils.unwrapObservable(value[className]);\n                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);\n            }\n        }\n    }\n};\n\nko.bindingHandlers['style'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor() || {});\n        for (var styleName in value) {\n            if (typeof styleName == \"string\") {\n                var styleValue = ko.utils.unwrapObservable(value[styleName]);\n                element.style[styleName] = styleValue || \"\"; // Empty string removes the value, whereas null/undefined have no effect\n            }\n        }\n    }\n};\n\nko.bindingHandlers['uniqueName'] = {\n    'init': function (element, valueAccessor) {\n        if (valueAccessor()) {\n            element.name = \"ko_unique_\" + (++ko.bindingHandlers['uniqueName'].currentIndex);\n\n            // Workaround IE 6/7 issue\n            // - https://github.com/SteveSanderson/knockout/issues/197\n            // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/\n            if (ko.utils.isIe6 || ko.utils.isIe7)\n                element.mergeAttributes(document.createElement(\"<input name='\" + element.name + \"'/>\"), false);\n        }\n    }\n};\nko.bindingHandlers['uniqueName'].currentIndex = 0;\n\nko.bindingHandlers['checked'] = {\n    'init': function (element, valueAccessor, allBindingsAccessor) {\n        var updateHandler = function() {\n            var valueToWrite;\n            if (element.type == \"checkbox\") {\n                valueToWrite = element.checked;\n            } else if ((element.type == \"radio\") && (element.checked)) {\n                valueToWrite = element.value;\n            } else {\n                return; // \"checked\" binding only responds to checkboxes and selected radio buttons\n            }\n\n            var modelValue = valueAccessor();\n            if ((element.type == \"checkbox\") && (ko.utils.unwrapObservable(modelValue) instanceof Array)) {\n                // For checkboxes bound to an array, we add/remove the checkbox value to that array\n                // This works for both observable and non-observable arrays\n                var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.unwrapObservable(modelValue), element.value);\n                if (element.checked && (existingEntryIndex < 0))\n                    modelValue.push(element.value);\n                else if ((!element.checked) && (existingEntryIndex >= 0))\n                    modelValue.splice(existingEntryIndex, 1);\n            } else {\n                ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'checked', valueToWrite, true);\n            }\n        };\n        ko.utils.registerEventHandler(element, \"click\", updateHandler);\n\n        // IE 6 won't allow radio buttons to be selected unless they have a name\n        if ((element.type == \"radio\") && !element.name)\n            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });\n    },\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n\n        if (element.type == \"checkbox\") {\n            if (value instanceof Array) {\n                // When bound to an array, the checkbox being checked represents its value being present in that array\n                element.checked = ko.utils.arrayIndexOf(value, element.value) >= 0;\n            } else {\n                // When bound to anything other value (not an array), the checkbox being checked represents the value being trueish\n                element.checked = value;\n            }\n        } else if (element.type == \"radio\") {\n            element.checked = (element.value == value);\n        }\n    }\n};\n\nvar attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };\nko.bindingHandlers['attr'] = {\n    'update': function(element, valueAccessor, allBindingsAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor()) || {};\n        for (var attrName in value) {\n            if (typeof attrName == \"string\") {\n                var attrValue = ko.utils.unwrapObservable(value[attrName]);\n\n                // To cover cases like \"attr: { checked:someProp }\", we want to remove the attribute entirely\n                // when someProp is a \"no value\"-like value (strictly null, false, or undefined)\n                // (because the absence of the \"checked\" attr is how to mark an element as not checked, etc.)\n                var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);\n                if (toRemove)\n                    element.removeAttribute(attrName);\n\n                // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the\n                // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,\n                // but instead of figuring out the mode, we'll just set the attribute through the Javascript\n                // property for IE <= 8.\n                if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {\n                    attrName = attrHtmlToJavascriptMap[attrName];\n                    if (toRemove)\n                        element.removeAttribute(attrName);\n                    else\n                        element[attrName] = attrValue;\n                } else if (!toRemove) {\n                    element.setAttribute(attrName, attrValue.toString());\n                }\n            }\n        }\n    }\n};\n\nko.bindingHandlers['hasfocus'] = {\n    'init': function(element, valueAccessor, allBindingsAccessor) {\n        var writeValue = function(valueToWrite) {\n            var modelValue = valueAccessor();\n            ko.jsonExpressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'hasfocus', valueToWrite, true);\n        };\n        ko.utils.registerEventHandler(element, \"focus\", function() { writeValue(true) });\n        ko.utils.registerEventHandler(element, \"focusin\", function() { writeValue(true) }); // For IE\n        ko.utils.registerEventHandler(element, \"blur\",  function() { writeValue(false) });\n        ko.utils.registerEventHandler(element, \"focusout\",  function() { writeValue(false) }); // For IE\n    },\n    'update': function(element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        value ? element.focus() : element.blur();\n        ko.utils.triggerEvent(element, value ? \"focusin\" : \"focusout\"); // For IE, which doesn't reliably fire \"focus\" or \"blur\" events synchronously\n    }\n};\n\n// \"with: someExpression\" is equivalent to \"template: { if: someExpression, data: someExpression }\"\nko.bindingHandlers['with'] = {\n    makeTemplateValueAccessor: function(valueAccessor) {\n        return function() { var value = valueAccessor(); return { 'if': value, 'data': value, 'templateEngine': ko.nativeTemplateEngine.instance } };\n    },\n    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['with'].makeTemplateValueAccessor(valueAccessor));\n    },\n    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['with'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);\n    }\n};\nko.jsonExpressionRewriting.bindingRewriteValidators['with'] = false; // Can't rewrite control flow bindings\nko.virtualElements.allowedBindings['with'] = true;\n\n// \"if: someExpression\" is equivalent to \"template: { if: someExpression }\"\nko.bindingHandlers['if'] = {\n    makeTemplateValueAccessor: function(valueAccessor) {\n        return function() { return { 'if': valueAccessor(), 'templateEngine': ko.nativeTemplateEngine.instance } };\n    },\n    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['if'].makeTemplateValueAccessor(valueAccessor));\n    },\n    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['if'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);\n    }\n};\nko.jsonExpressionRewriting.bindingRewriteValidators['if'] = false; // Can't rewrite control flow bindings\nko.virtualElements.allowedBindings['if'] = true;\n\n// \"ifnot: someExpression\" is equivalent to \"template: { ifnot: someExpression }\"\nko.bindingHandlers['ifnot'] = {\n    makeTemplateValueAccessor: function(valueAccessor) {\n        return function() { return { 'ifnot': valueAccessor(), 'templateEngine': ko.nativeTemplateEngine.instance } };\n    },\n    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['ifnot'].makeTemplateValueAccessor(valueAccessor));\n    },\n    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['ifnot'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);\n    }\n};\nko.jsonExpressionRewriting.bindingRewriteValidators['ifnot'] = false; // Can't rewrite control flow bindings\nko.virtualElements.allowedBindings['ifnot'] = true;\n\n// \"foreach: someExpression\" is equivalent to \"template: { foreach: someExpression }\"\n// \"foreach: { data: someExpression, afterAdd: myfn }\" is equivalent to \"template: { foreach: someExpression, afterAdd: myfn }\"\nko.bindingHandlers['foreach'] = {\n    makeTemplateValueAccessor: function(valueAccessor) {\n        return function() {\n            var bindingValue = ko.utils.unwrapObservable(valueAccessor());\n\n            // If bindingValue is the array, just pass it on its own\n            if ((!bindingValue) || typeof bindingValue.length == \"number\")\n                return { 'foreach': bindingValue, 'templateEngine': ko.nativeTemplateEngine.instance };\n\n            // If bindingValue.data is the array, preserve all relevant options\n            return {\n                'foreach': bindingValue['data'],\n                'includeDestroyed': bindingValue['includeDestroyed'],\n                'afterAdd': bindingValue['afterAdd'],\n                'beforeRemove': bindingValue['beforeRemove'],\n                'afterRender': bindingValue['afterRender'],\n                'templateEngine': ko.nativeTemplateEngine.instance\n            };\n        };\n    },\n    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));\n    },\n    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);\n    }\n};\nko.jsonExpressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings\nko.virtualElements.allowedBindings['foreach'] = true;\n// If you want to make a custom template engine,\n//\n// [1] Inherit from this class (like ko.nativeTemplateEngine does)\n// [2] Override 'renderTemplateSource', supplying a function with this signature:\n//\n//        function (templateSource, bindingContext, options) {\n//            // - templateSource.text() is the text of the template you should render\n//            // - bindingContext.$data is the data you should pass into the template\n//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,\n//            //     and bindingContext.$root available in the template too\n//            // - options gives you access to any other properties set on \"data-bind: { template: options }\"\n//            //\n//            // Return value: an array of DOM nodes\n//        }\n//\n// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:\n//\n//        function (script) {\n//            // Return value: Whatever syntax means \"Evaluate the JavaScript statement 'script' and output the result\"\n//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'\n//        }\n//\n//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.\n//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)\n//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.\n\nko.templateEngine = function () { };\n\nko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {\n    throw new Error(\"Override renderTemplateSource\");\n};\n\nko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {\n    throw new Error(\"Override createJavaScriptEvaluatorBlock\");\n};\n\nko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {\n    // Named template\n    if (typeof template == \"string\") {\n        templateDocument = templateDocument || document;\n        var elem = templateDocument.getElementById(template);\n        if (!elem)\n            throw new Error(\"Cannot find template with ID \" + template);\n        return new ko.templateSources.domElement(elem);\n    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {\n        // Anonymous template\n        return new ko.templateSources.anonymousTemplate(template);\n    } else\n        throw new Error(\"Unknown template type: \" + template);\n};\n\nko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {\n    var templateSource = this['makeTemplateSource'](template, templateDocument);\n    return this['renderTemplateSource'](templateSource, bindingContext, options);\n};\n\nko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {\n    // Skip rewriting if requested\n    if (this['allowTemplateRewriting'] === false)\n        return true;\n\n    // Perf optimisation - see below\n    var templateIsInExternalDocument = templateDocument && templateDocument != document;\n    if (!templateIsInExternalDocument && this.knownRewrittenTemplates && this.knownRewrittenTemplates[template])\n        return true;\n\n    return this['makeTemplateSource'](template, templateDocument)['data'](\"isRewritten\");\n};\n\nko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {\n    var templateSource = this['makeTemplateSource'](template, templateDocument);\n    var rewritten = rewriterCallback(templateSource['text']());\n    templateSource['text'](rewritten);\n    templateSource['data'](\"isRewritten\", true);\n\n    // Perf optimisation - for named templates, track which ones have been rewritten so we can\n    // answer 'isTemplateRewritten' *without* having to use getElementById (which is slow on IE < 8)\n    //\n    // Note that we only cache the status for templates in the main document, because caching on a per-doc\n    // basis complicates the implementation excessively. In a future version of KO, we will likely remove\n    // this 'isRewritten' cache entirely anyway, because the benefit is extremely minor and only applies\n    // to rewritable templates, which are pretty much deprecated since KO 2.0.\n    var templateIsInExternalDocument = templateDocument && templateDocument != document;\n    if (!templateIsInExternalDocument && typeof template == \"string\") {\n        this.knownRewrittenTemplates = this.knownRewrittenTemplates || {};\n        this.knownRewrittenTemplates[template] = true;\n    }\n};\n\nko.exportSymbol('templateEngine', ko.templateEngine);\n\nko.templateRewriting = (function () {\n    var memoizeDataBindingAttributeSyntaxRegex = /(<[a-z]+\\d*(\\s+(?!data-bind=)[a-z0-9\\-]+(=(\\\"[^\\\"]*\\\"|\\'[^\\']*\\'))?)*\\s+)data-bind=([\"'])([\\s\\S]*?)\\5/gi;\n    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\\s*ko\\b\\s*([\\s\\S]*?)\\s*-->/g;\n\n    function validateDataBindValuesForRewriting(keyValueArray) {\n        var allValidators = ko.jsonExpressionRewriting.bindingRewriteValidators;\n        for (var i = 0; i < keyValueArray.length; i++) {\n            var key = keyValueArray[i]['key'];\n            if (allValidators.hasOwnProperty(key)) {\n                var validator = allValidators[key];\n\n                if (typeof validator === \"function\") {\n                    var possibleErrorMessage = validator(keyValueArray[i]['value']);\n                    if (possibleErrorMessage)\n                        throw new Error(possibleErrorMessage);\n                } else if (!validator) {\n                    throw new Error(\"This template engine does not support the '\" + key + \"' binding within its templates\");\n                }\n            }\n        }\n    }\n\n    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, templateEngine) {\n        var dataBindKeyValueArray = ko.jsonExpressionRewriting.parseObjectLiteral(dataBindAttributeValue);\n        validateDataBindValuesForRewriting(dataBindKeyValueArray);\n        var rewrittenDataBindAttributeValue = ko.jsonExpressionRewriting.insertPropertyAccessorsIntoJson(dataBindKeyValueArray);\n\n        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional\n        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this\n        // extra indirection.\n        var applyBindingsToNextSiblingScript = \"ko.templateRewriting.applyMemoizedBindingsToNextSibling(function() { \\\n            return (function() { return { \" + rewrittenDataBindAttributeValue + \" } })() \\\n        })\";\n        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;\n    }\n\n    return {\n        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {\n            if (!templateEngine['isTemplateRewritten'](template, templateDocument))\n                templateEngine['rewriteTemplate'](template, function (htmlString) {\n                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);\n                }, templateDocument);\n        },\n\n        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {\n            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {\n                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[6], /* tagToRetain: */ arguments[1], templateEngine);\n            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {\n                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ \"<!-- ko -->\", templateEngine);\n            });\n        },\n\n        applyMemoizedBindingsToNextSibling: function (bindings) {\n            return ko.memoization.memoize(function (domNode, bindingContext) {\n                if (domNode.nextSibling)\n                    ko.applyBindingsToNode(domNode.nextSibling, bindings, bindingContext);\n            });\n        }\n    }\n})();\n\nko.exportSymbol('templateRewriting', ko.templateRewriting);\nko.exportSymbol('templateRewriting.applyMemoizedBindingsToNextSibling', ko.templateRewriting.applyMemoizedBindingsToNextSibling); // Exported only because it has to be referenced by string lookup from within rewritten template\n(function() {\n    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving\n    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)\n    //\n    // Two are provided by default:\n    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element\n    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but\n    //                                           without reading/writing the actual element text content, since it will be overwritten\n    //                                           with the rendered template output.\n    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.\n    // Template sources need to have the following functions:\n    //   text()             - returns the template text from your storage location\n    //   text(value)        - writes the supplied template text to your storage location\n    //   data(key)          - reads values stored using data(key, value) - see below\n    //   data(key, value)   - associates \"value\" with this template and the key \"key\". Is used to store information like \"isRewritten\".\n    //\n    // Optionally, template sources can also have the following functions:\n    //   nodes()            - returns a DOM element containing the nodes of this template, where available\n    //   nodes(value)       - writes the given DOM element to your storage location\n    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()\n    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().\n    //\n    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were\n    // using and overriding \"makeTemplateSource\" to return an instance of your custom template source.\n\n    ko.templateSources = {};\n\n    // ---- ko.templateSources.domElement -----\n\n    ko.templateSources.domElement = function(element) {\n        this.domElement = element;\n    }\n\n    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {\n        var tagNameLower = ko.utils.tagNameLower(this.domElement),\n            elemContentsProperty = tagNameLower === \"script\" ? \"text\"\n                                 : tagNameLower === \"textarea\" ? \"value\"\n                                 : \"innerHTML\";\n\n        if (arguments.length == 0) {\n            return this.domElement[elemContentsProperty];\n        } else {\n            var valueToWrite = arguments[0];\n            if (elemContentsProperty === \"innerHTML\")\n                ko.utils.setHtml(this.domElement, valueToWrite);\n            else\n                this.domElement[elemContentsProperty] = valueToWrite;\n        }\n    };\n\n    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {\n        if (arguments.length === 1) {\n            return ko.utils.domData.get(this.domElement, \"templateSourceData_\" + key);\n        } else {\n            ko.utils.domData.set(this.domElement, \"templateSourceData_\" + key, arguments[1]);\n        }\n    };\n\n    // ---- ko.templateSources.anonymousTemplate -----\n    // Anonymous templates are normally saved/retrieved as DOM nodes through \"nodes\".\n    // For compatibility, you can also read \"text\"; it will be serialized from the nodes on demand.\n    // Writing to \"text\" is still supported, but then the template data will not be available as DOM nodes.\n\n    var anonymousTemplatesDomDataKey = \"__ko_anon_template__\";\n    ko.templateSources.anonymousTemplate = function(element) {\n        this.domElement = element;\n    }\n    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();\n    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {\n        if (arguments.length == 0) {\n            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};\n            if (templateData.textData === undefined && templateData.containerData)\n                templateData.textData = templateData.containerData.innerHTML;\n            return templateData.textData;\n        } else {\n            var valueToWrite = arguments[0];\n            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {textData: valueToWrite});\n        }\n    };\n    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {\n        if (arguments.length == 0) {\n            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};\n            return templateData.containerData;\n        } else {\n            var valueToWrite = arguments[0];\n            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {containerData: valueToWrite});\n        }\n    };\n\n    ko.exportSymbol('templateSources', ko.templateSources);\n    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);\n    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);\n})();\n(function () {\n    var _templateEngine;\n    ko.setTemplateEngine = function (templateEngine) {\n        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))\n            throw new Error(\"templateEngine must inherit from ko.templateEngine\");\n        _templateEngine = templateEngine;\n    }\n\n    function invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, action) {\n        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);\n        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {\n            nextInQueue = ko.virtualElements.nextSibling(node);\n            if (node.nodeType === 1 || node.nodeType === 8)\n                action(node);\n        }\n    }\n\n    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {\n        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element\n        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because\n        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,\n        // (1) Does a regular \"applyBindings\" to associate bindingContext with this node and to activate any non-memoized bindings\n        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)\n\n        if (continuousNodeArray.length) {\n            var firstNode = continuousNodeArray[0], lastNode = continuousNodeArray[continuousNodeArray.length - 1];\n\n            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)\n            // whereas a regular applyBindings won't introduce new memoized nodes\n            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function(node) {\n                ko.applyBindings(bindingContext, node);\n            });\n            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function(node) {\n                ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);\n            });\n        }\n    }\n\n    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {\n        return nodeOrNodeArray.nodeType ? nodeOrNodeArray\n                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]\n                                        : null;\n    }\n\n    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {\n        options = options || {};\n        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n        var templateDocument = firstTargetNode && firstTargetNode.ownerDocument;\n        var templateEngineToUse = (options['templateEngine'] || _templateEngine);\n        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);\n        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);\n\n        // Loosely check result is an array of DOM nodes\n        if ((typeof renderedNodesArray.length != \"number\") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != \"number\"))\n            throw new Error(\"Template engine must return an array of DOM nodes\");\n\n        var haveAddedNodesToParent = false;\n        switch (renderMode) {\n            case \"replaceChildren\":\n                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);\n                haveAddedNodesToParent = true;\n                break;\n            case \"replaceNode\":\n                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);\n                haveAddedNodesToParent = true;\n                break;\n            case \"ignoreTargetNode\": break;\n            default:\n                throw new Error(\"Unknown renderMode: \" + renderMode);\n        }\n\n        if (haveAddedNodesToParent) {\n            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);\n            if (options['afterRender'])\n                options['afterRender'](renderedNodesArray, bindingContext['$data']);\n        }\n\n        return renderedNodesArray;\n    }\n\n    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {\n        options = options || {};\n        if ((options['templateEngine'] || _templateEngine) == undefined)\n            throw new Error(\"Set a template engine before calling renderTemplate\");\n        renderMode = renderMode || \"replaceChildren\";\n\n        if (targetNodeOrNodeArray) {\n            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n\n            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)\n            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == \"replaceNode\") ? firstTargetNode.parentNode : firstTargetNode;\n\n            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes\n                function () {\n                    // Ensure we've got a proper binding context to work with\n                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))\n                        ? dataOrBindingContext\n                        : new ko.bindingContext(ko.utils.unwrapObservable(dataOrBindingContext));\n\n                    // Support selecting template as a function of the data being rendered\n                    var templateName = typeof(template) == 'function' ? template(bindingContext['$data']) : template;\n\n                    var renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);\n                    if (renderMode == \"replaceNode\") {\n                        targetNodeOrNodeArray = renderedNodesArray;\n                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n                    }\n                },\n                null,\n                { 'disposeWhen': whenToDispose, 'disposeWhenNodeIsRemoved': activelyDisposeWhenNodeIsRemoved }\n            );\n        } else {\n            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node\n            return ko.memoization.memoize(function (domNode) {\n                ko.renderTemplate(template, dataOrBindingContext, options, domNode, \"replaceNode\");\n            });\n        }\n    };\n\n    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {\n        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then\n        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.\n        var arrayItemContext;\n\n        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode\n        var executeTemplateForArrayItem = function (arrayValue, index) {\n            // Support selecting template as a function of the data being rendered\n            var templateName = typeof(template) == 'function' ? template(arrayValue) : template;\n            arrayItemContext = parentBindingContext['createChildContext'](ko.utils.unwrapObservable(arrayValue));\n            arrayItemContext['$index'] = index;\n            return executeTemplate(null, \"ignoreTargetNode\", templateName, arrayItemContext, options);\n        }\n\n        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode\n        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {\n            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);\n            if (options['afterRender'])\n                options['afterRender'](addedNodesArray, arrayValue);\n        };\n\n        return ko.dependentObservable(function () {\n            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];\n            if (typeof unwrappedArray.length == \"undefined\") // Coerce single value into array\n                unwrappedArray = [unwrappedArray];\n\n            // Filter out any entries marked as destroyed\n            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {\n                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);\n            });\n\n            ko.utils.setDomNodeChildrenFromArrayMapping(targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback);\n\n        }, null, { 'disposeWhenNodeIsRemoved': targetNode });\n    };\n\n    var templateSubscriptionDomDataKey = '__ko__templateSubscriptionDomDataKey__';\n    function disposeOldSubscriptionAndStoreNewOne(element, newSubscription) {\n        var oldSubscription = ko.utils.domData.get(element, templateSubscriptionDomDataKey);\n        if (oldSubscription && (typeof(oldSubscription.dispose) == 'function'))\n            oldSubscription.dispose();\n        ko.utils.domData.set(element, templateSubscriptionDomDataKey, newSubscription);\n    }\n\n    ko.bindingHandlers['template'] = {\n        'init': function(element, valueAccessor) {\n            // Support anonymous templates\n            var bindingValue = ko.utils.unwrapObservable(valueAccessor());\n            if ((typeof bindingValue != \"string\") && (!bindingValue['name']) && (element.nodeType == 1 || element.nodeType == 8)) {\n                // It's an anonymous template - store the element contents, then clear the element\n                var templateNodes = element.nodeType == 1 ? element.childNodes : ko.virtualElements.childNodes(element),\n                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent\n                new ko.templateSources.anonymousTemplate(element)['nodes'](container);\n            }\n            return { 'controlsDescendantBindings': true };\n        },\n        'update': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n            var bindingValue = ko.utils.unwrapObservable(valueAccessor());\n            var templateName;\n            var shouldDisplay = true;\n\n            if (typeof bindingValue == \"string\") {\n                templateName = bindingValue;\n            } else {\n                templateName = bindingValue['name'];\n\n                // Support \"if\"/\"ifnot\" conditions\n                if ('if' in bindingValue)\n                    shouldDisplay = shouldDisplay && ko.utils.unwrapObservable(bindingValue['if']);\n                if ('ifnot' in bindingValue)\n                    shouldDisplay = shouldDisplay && !ko.utils.unwrapObservable(bindingValue['ifnot']);\n            }\n\n            var templateSubscription = null;\n\n            if ((typeof bindingValue === 'object') && ('foreach' in bindingValue)) { // Note: can't use 'in' operator on strings\n                // Render once for each data point (treating data set as empty if shouldDisplay==false)\n                var dataArray = (shouldDisplay && bindingValue['foreach']) || [];\n                templateSubscription = ko.renderTemplateForEach(templateName || element, dataArray, /* options: */ bindingValue, element, bindingContext);\n            } else {\n                if (shouldDisplay) {\n                    // Render once for this single data point (or use the viewModel if no data was provided)\n                    var innerBindingContext = (typeof bindingValue == 'object') && ('data' in bindingValue)\n                        ? bindingContext['createChildContext'](ko.utils.unwrapObservable(bindingValue['data'])) // Given an explitit 'data' value, we create a child binding context for it\n                        : bindingContext;                                                                       // Given no explicit 'data' value, we retain the same binding context\n                    templateSubscription = ko.renderTemplate(templateName || element, innerBindingContext, /* options: */ bindingValue, element);\n                } else\n                    ko.virtualElements.emptyNode(element);\n            }\n\n            // It only makes sense to have a single template subscription per element (otherwise which one should have its output displayed?)\n            disposeOldSubscriptionAndStoreNewOne(element, templateSubscription);\n        }\n    };\n\n    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.\n    ko.jsonExpressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {\n        var parsedBindingValue = ko.jsonExpressionRewriting.parseObjectLiteral(bindingValue);\n\n        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])\n            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)\n\n        if (ko.jsonExpressionRewriting.keyValueArrayContainsKey(parsedBindingValue, \"name\"))\n            return null; // Named templates can be rewritten, so return \"no error\"\n        return \"This template engine does not support anonymous templates nested within its templates\";\n    };\n\n    ko.virtualElements.allowedBindings['template'] = true;\n})();\n\nko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);\nko.exportSymbol('renderTemplate', ko.renderTemplate);\n\n(function () {\n    // Simple calculation based on Levenshtein distance.\n    function calculateEditDistanceMatrix(oldArray, newArray, maxAllowedDistance) {\n        var distances = [];\n        for (var i = 0; i <= newArray.length; i++)\n            distances[i] = [];\n\n        // Top row - transform old array into empty array via deletions\n        for (var i = 0, j = Math.min(oldArray.length, maxAllowedDistance); i <= j; i++)\n            distances[0][i] = i;\n\n        // Left row - transform empty array into new array via additions\n        for (var i = 1, j = Math.min(newArray.length, maxAllowedDistance); i <= j; i++) {\n            distances[i][0] = i;\n        }\n\n        // Fill out the body of the array\n        var oldIndex, oldIndexMax = oldArray.length, newIndex, newIndexMax = newArray.length;\n        var distanceViaAddition, distanceViaDeletion;\n        for (oldIndex = 1; oldIndex <= oldIndexMax; oldIndex++) {\n            var newIndexMinForRow = Math.max(1, oldIndex - maxAllowedDistance);\n            var newIndexMaxForRow = Math.min(newIndexMax, oldIndex + maxAllowedDistance);\n            for (newIndex = newIndexMinForRow; newIndex <= newIndexMaxForRow; newIndex++) {\n                if (oldArray[oldIndex - 1] === newArray[newIndex - 1])\n                    distances[newIndex][oldIndex] = distances[newIndex - 1][oldIndex - 1];\n                else {\n                    var northDistance = distances[newIndex - 1][oldIndex] === undefined ? Number.MAX_VALUE : distances[newIndex - 1][oldIndex] + 1;\n                    var westDistance = distances[newIndex][oldIndex - 1] === undefined ? Number.MAX_VALUE : distances[newIndex][oldIndex - 1] + 1;\n                    distances[newIndex][oldIndex] = Math.min(northDistance, westDistance);\n                }\n            }\n        }\n\n        return distances;\n    }\n\n    function findEditScriptFromEditDistanceMatrix(editDistanceMatrix, oldArray, newArray) {\n        var oldIndex = oldArray.length;\n        var newIndex = newArray.length;\n        var editScript = [];\n        var maxDistance = editDistanceMatrix[newIndex][oldIndex];\n        if (maxDistance === undefined)\n            return null; // maxAllowedDistance must be too small\n        while ((oldIndex > 0) || (newIndex > 0)) {\n            var me = editDistanceMatrix[newIndex][oldIndex];\n            var distanceViaAdd = (newIndex > 0) ? editDistanceMatrix[newIndex - 1][oldIndex] : maxDistance + 1;\n            var distanceViaDelete = (oldIndex > 0) ? editDistanceMatrix[newIndex][oldIndex - 1] : maxDistance + 1;\n            var distanceViaRetain = (newIndex > 0) && (oldIndex > 0) ? editDistanceMatrix[newIndex - 1][oldIndex - 1] : maxDistance + 1;\n            if ((distanceViaAdd === undefined) || (distanceViaAdd < me - 1)) distanceViaAdd = maxDistance + 1;\n            if ((distanceViaDelete === undefined) || (distanceViaDelete < me - 1)) distanceViaDelete = maxDistance + 1;\n            if (distanceViaRetain < me - 1) distanceViaRetain = maxDistance + 1;\n\n            if ((distanceViaAdd <= distanceViaDelete) && (distanceViaAdd < distanceViaRetain)) {\n                editScript.push({ status: \"added\", value: newArray[newIndex - 1] });\n                newIndex--;\n            } else if ((distanceViaDelete < distanceViaAdd) && (distanceViaDelete < distanceViaRetain)) {\n                editScript.push({ status: \"deleted\", value: oldArray[oldIndex - 1] });\n                oldIndex--;\n            } else {\n                editScript.push({ status: \"retained\", value: oldArray[oldIndex - 1] });\n                newIndex--;\n                oldIndex--;\n            }\n        }\n        return editScript.reverse();\n    }\n\n    ko.utils.compareArrays = function (oldArray, newArray, maxEditsToConsider) {\n        if (maxEditsToConsider === undefined) {\n            return ko.utils.compareArrays(oldArray, newArray, 1)                 // First consider likely case where there is at most one edit (very fast)\n                || ko.utils.compareArrays(oldArray, newArray, 10)                // If that fails, account for a fair number of changes while still being fast\n                || ko.utils.compareArrays(oldArray, newArray, Number.MAX_VALUE); // Ultimately give the right answer, even though it may take a long time\n        } else {\n            oldArray = oldArray || [];\n            newArray = newArray || [];\n            var editDistanceMatrix = calculateEditDistanceMatrix(oldArray, newArray, maxEditsToConsider);\n            return findEditScriptFromEditDistanceMatrix(editDistanceMatrix, oldArray, newArray);\n        }\n    };\n})();\n\nko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);\n\n(function () {\n    // Objective:\n    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,\n    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node\n    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node\n    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we\n    //   previously mapped - retain those nodes, and just insert/delete other ones\n\n    // \"callbackAfterAddingNodes\" will be invoked after any \"mapping\"-generated nodes are inserted into the container node\n    // You can use this, for example, to activate bindings on those nodes.\n\n    function fixUpVirtualElements(contiguousNodeArray) {\n        // Ensures that contiguousNodeArray really *is* an array of contiguous siblings, even if some of the interior\n        // ones have changed since your array was first built (e.g., because your array contains virtual elements, and\n        // their virtual children changed when binding was applied to them).\n        // This is needed so that we can reliably remove or update the nodes corresponding to a given array item\n\n        if (contiguousNodeArray.length > 2) {\n            // Build up the actual new contiguous node set\n            var current = contiguousNodeArray[0], last = contiguousNodeArray[contiguousNodeArray.length - 1], newContiguousSet = [current];\n            while (current !== last) {\n                current = current.nextSibling;\n                if (!current) // Won't happen, except if the developer has manually removed some DOM elements (then we're in an undefined scenario)\n                    return;\n                newContiguousSet.push(current);\n            }\n\n            // ... then mutate the input array to match this.\n            // (The following line replaces the contents of contiguousNodeArray with newContiguousSet)\n            Array.prototype.splice.apply(contiguousNodeArray, [0, contiguousNodeArray.length].concat(newContiguousSet));\n        }\n    }\n\n    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {\n        // Map this array value inside a dependentObservable so we re-map when any dependency changes\n        var mappedNodes = [];\n        var dependentObservable = ko.dependentObservable(function() {\n            var newMappedNodes = mapping(valueToMap, index) || [];\n\n            // On subsequent evaluations, just replace the previously-inserted DOM nodes\n            if (mappedNodes.length > 0) {\n                fixUpVirtualElements(mappedNodes);\n                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);\n                if (callbackAfterAddingNodes)\n                    callbackAfterAddingNodes(valueToMap, newMappedNodes);\n            }\n\n            // Replace the contents of the mappedNodes array, thereby updating the record\n            // of which nodes would be deleted if valueToMap was itself later removed\n            mappedNodes.splice(0, mappedNodes.length);\n            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);\n        }, null, { 'disposeWhenNodeIsRemoved': containerNode, 'disposeWhen': function() { return (mappedNodes.length == 0) || !ko.utils.domNodeIsAttachedToDocument(mappedNodes[0]) } });\n        return { mappedNodes : mappedNodes, dependentObservable : dependentObservable };\n    }\n\n    var lastMappingResultDomDataKey = \"setDomNodeChildrenFromArrayMapping_lastMappingResult\";\n\n    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {\n        // Compare the provided array against the previous one\n        array = array || [];\n        options = options || {};\n        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;\n        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];\n        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });\n        var editScript = ko.utils.compareArrays(lastArray, array);\n\n        // Build the new mapping result\n        var newMappingResult = [];\n        var lastMappingResultIndex = 0;\n        var nodesToDelete = [];\n        var newMappingResultIndex = 0;\n        var nodesAdded = [];\n        var insertAfterNode = null;\n        for (var i = 0, j = editScript.length; i < j; i++) {\n            switch (editScript[i].status) {\n                case \"retained\":\n                    // Just keep the information - don't touch the nodes\n                    var dataToRetain = lastMappingResult[lastMappingResultIndex];\n                    dataToRetain.indexObservable(newMappingResultIndex);\n                    newMappingResultIndex = newMappingResult.push(dataToRetain);\n                    if (dataToRetain.domNodes.length > 0)\n                        insertAfterNode = dataToRetain.domNodes[dataToRetain.domNodes.length - 1];\n                    lastMappingResultIndex++;\n                    break;\n\n                case \"deleted\":\n                    // Stop tracking changes to the mapping for these nodes\n                    lastMappingResult[lastMappingResultIndex].dependentObservable.dispose();\n\n                    // Queue these nodes for later removal\n                    fixUpVirtualElements(lastMappingResult[lastMappingResultIndex].domNodes);\n                    ko.utils.arrayForEach(lastMappingResult[lastMappingResultIndex].domNodes, function (node) {\n                        nodesToDelete.push({\n                          element: node,\n                          index: i,\n                          value: editScript[i].value\n                        });\n                        insertAfterNode = node;\n                    });\n                    lastMappingResultIndex++;\n                    break;\n\n                case \"added\":\n                    var valueToMap = editScript[i].value;\n                    var indexObservable = ko.observable(newMappingResultIndex);\n                    var mapData = mapNodeAndRefreshWhenChanged(domNode, mapping, valueToMap, callbackAfterAddingNodes, indexObservable);\n                    var mappedNodes = mapData.mappedNodes;\n\n                    // On the first evaluation, insert the nodes at the current insertion point\n                    newMappingResultIndex = newMappingResult.push({\n                        arrayEntry: editScript[i].value,\n                        domNodes: mappedNodes,\n                        dependentObservable: mapData.dependentObservable,\n                        indexObservable: indexObservable\n                    });\n                    for (var nodeIndex = 0, nodeIndexMax = mappedNodes.length; nodeIndex < nodeIndexMax; nodeIndex++) {\n                        var node = mappedNodes[nodeIndex];\n                        nodesAdded.push({\n                          element: node,\n                          index: i,\n                          value: editScript[i].value\n                        });\n                        if (insertAfterNode == null) {\n                            // Insert \"node\" (the newly-created node) as domNode's first child\n                            ko.virtualElements.prepend(domNode, node);\n                        } else {\n                            // Insert \"node\" into \"domNode\" immediately after \"insertAfterNode\"\n                            ko.virtualElements.insertAfter(domNode, node, insertAfterNode);\n                        }\n                        insertAfterNode = node;\n                    }\n                    if (callbackAfterAddingNodes)\n                        callbackAfterAddingNodes(valueToMap, mappedNodes, indexObservable);\n                    break;\n            }\n        }\n\n        ko.utils.arrayForEach(nodesToDelete, function (node) { ko.cleanNode(node.element) });\n\n        var invokedBeforeRemoveCallback = false;\n        if (!isFirstExecution) {\n            if (options['afterAdd']) {\n                for (var i = 0; i < nodesAdded.length; i++)\n                    options['afterAdd'](nodesAdded[i].element, nodesAdded[i].index, nodesAdded[i].value);\n            }\n            if (options['beforeRemove']) {\n                for (var i = 0; i < nodesToDelete.length; i++)\n                    options['beforeRemove'](nodesToDelete[i].element, nodesToDelete[i].index, nodesToDelete[i].value);\n                invokedBeforeRemoveCallback = true;\n            }\n        }\n        if (!invokedBeforeRemoveCallback && nodesToDelete.length) {\n            for (var i = 0; i < nodesToDelete.length; i++) {\n                var element = nodesToDelete[i].element;\n                if (element.parentNode)\n                    element.parentNode.removeChild(element);\n            }\n        }\n\n        // Store a copy of the array items we just considered so we can difference it next time\n        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);\n    }\n})();\n\nko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);\nko.nativeTemplateEngine = function () {\n    this['allowTemplateRewriting'] = false;\n}\n\nko.nativeTemplateEngine.prototype = new ko.templateEngine();\nko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {\n    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly\n        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,\n        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;\n\n    if (templateNodes) {\n        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);\n    } else {\n        var templateText = templateSource['text']();\n        return ko.utils.parseHtmlFragment(templateText);\n    }\n};\n\nko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();\nko.setTemplateEngine(ko.nativeTemplateEngine.instance);\n\nko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);\n(function() {\n    ko.jqueryTmplTemplateEngine = function () {\n        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl\n        // doesn't expose a version number, so we have to infer it.\n        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,\n        // which KO internally refers to as version \"2\", so older versions are no longer detected.\n        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {\n            if ((typeof(jQuery) == \"undefined\") || !(jQuery['tmpl']))\n                return 0;\n            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.\n            try {\n                if (jQuery['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {\n                    // Since 1.0.0pre, custom tags should append markup to an array called \"__\"\n                    return 2; // Final version of jquery.tmpl\n                }\n            } catch(ex) { /* Apparently not the version we were looking for */ }\n\n            return 1; // Any older version that we don't support\n        })();\n\n        function ensureHasReferencedJQueryTemplates() {\n            if (jQueryTmplVersion < 2)\n                throw new Error(\"Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.\");\n        }\n\n        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {\n            return jQuery['tmpl'](compiledTemplate, data, jQueryTemplateOptions);\n        }\n\n        this['renderTemplateSource'] = function(templateSource, bindingContext, options) {\n            options = options || {};\n            ensureHasReferencedJQueryTemplates();\n\n            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)\n            var precompiled = templateSource['data']('precompiled');\n            if (!precompiled) {\n                var templateText = templateSource['text']() || \"\";\n                // Wrap in \"with($whatever.koBindingContext) { ... }\"\n                templateText = \"{{ko_with $item.koBindingContext}}\" + templateText + \"{{/ko_with}}\";\n\n                precompiled = jQuery['template'](null, templateText);\n                templateSource['data']('precompiled', precompiled);\n            }\n\n            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays\n            var jQueryTemplateOptions = jQuery['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);\n\n            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);\n            resultNodes['appendTo'](document.createElement(\"div\")); // Using \"appendTo\" forces jQuery/jQuery.tmpl to perform necessary cleanup work\n\n            jQuery['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders\n            return resultNodes;\n        };\n\n        this['createJavaScriptEvaluatorBlock'] = function(script) {\n            return \"{{ko_code ((function() { return \" + script + \" })()) }}\";\n        };\n\n        this['addTemplate'] = function(templateName, templateMarkup) {\n            document.write(\"<script type='text/html' id='\" + templateName + \"'>\" + templateMarkup + \"</script>\");\n        };\n\n        if (jQueryTmplVersion > 0) {\n            jQuery['tmpl']['tag']['ko_code'] = {\n                open: \"__.push($1 || '');\"\n            };\n            jQuery['tmpl']['tag']['ko_with'] = {\n                open: \"with($1) {\",\n                close: \"} \"\n            };\n        }\n    };\n\n    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();\n\n    // Use this one by default *only if jquery.tmpl is referenced*\n    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();\n    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)\n        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);\n\n    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);\n})();\n});\n})(window,document,navigator);\n//@ sourceURL=vendor/knockout-debug.js\n});");

require("main");

$(function () { $('head').append($('<script src="js/src/vendor/socket.js"></script>')); $('head').append($('<script src="js/src/vendor/livereload.js"></script>'));});